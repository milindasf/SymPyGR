\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\gdef\minted@oldcachelist{,
  default-pyg-prefix.pygstyle,
  default.pygstyle,
  6CF00026FA6B38AA70CD2146CB401D1298563B22D6D85590C234738A097E9143.pygtex,
  CA85EF1CFF3E9B194CB9A28D46488E4A98563B22D6D85590C234738A097E9143.pygtex}
\providecommand \oddpage@label [2]{}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces \fontsize  {20.74}{25}\selectfont  Comparison between \textsc  {ET}\nobreakspace  {} and \textsc  {Dendro-GR}\ for number of spatial points with increasing mass ratios. Note that these are not from complete simulations, but it illustrates the rate of increase for both approaches.\relax }}{1}{figure.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces \fontsize  {20.74}{25}\selectfont  Efficiency of zip/unzip operations with adaptivitve octrees.\relax }}{1}{figure.2}}
\newlabel{fig:w:a}{{3a}{1}{$f(x) \in V_0 \subset V_1 \subset V_2$ \relax }{subfigure.3.1}{}}
\newlabel{sub@fig:w:a}{{a}{1}{$f(x) \in V_0 \subset V_1 \subset V_2$ \relax }{subfigure.3.1}{}}
\newlabel{fig:w:b}{{3b}{1}{$W_{i,k}=|f(V_{i,k})-I(f(V{i-1,:}))|$ \relax }{subfigure.3.2}{}}
\newlabel{sub@fig:w:b}{{b}{1}{$W_{i,k}=|f(V_{i,k})-I(f(V{i-1,:}))|$ \relax }{subfigure.3.2}{}}
\newlabel{fig:w:c}{{3c}{1}{$W_{i,k}\geq \epsilon \geq 0$ \relax }{subfigure.3.3}{}}
\newlabel{sub@fig:w:c}{{c}{1}{$W_{i,k}\geq \epsilon \geq 0$ \relax }{subfigure.3.3}{}}
\newlabel{fig:w:d}{{3d}{1}{wavelet/sparse representation of $f(x)$ \relax }{subfigure.3.4}{}}
\newlabel{sub@fig:w:d}{{d}{1}{wavelet/sparse representation of $f(x)$ \relax }{subfigure.3.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces For a given function $f:V\rightarrow \mathcal  {R}$ let $V_i \subset V$ be the finite dimensional approximation of $f$ (see figure \ref  {fig:w:a}). As number of nodes increases (i.e. going from $V_i$ to $V_{i+1}$) for each additional node introduced, we compute wavelet coefficients based on the absolute difference between $f(V_{i,k})$ and interpolated value from previous level $f(V_{i-1,:})$ (see figure \ref  {fig:w:b}). In figure \ref  {fig:w:c} shows the chosen nodes that violate specified wavelet tolerance $epsilon$ and these nodal wavelets are stored as the sparse/wavelet representation of function $f$ (see figure \ref  {fig:w:d}).\relax }}{1}{figure.3}}
\newlabel{fig:wavelets}{{3}{1}{For a given function $f:V\rightarrow \mathcal {R}$ let $V_i \subset V$ be the finite dimensional approximation of $f$ (see figure \ref {fig:w:a}). As number of nodes increases (i.e. going from $V_i$ to $V_{i+1}$) for each additional node introduced, we compute wavelet coefficients based on the absolute difference between $f(V_{i,k})$ and interpolated value from previous level $f(V_{i-1,:})$ (see figure \ref {fig:w:b}). In figure \ref {fig:w:c} shows the chosen nodes that violate specified wavelet tolerance $epsilon$ and these nodal wavelets are stored as the sparse/wavelet representation of function $f$ (see figure \ref {fig:w:d}).\relax }{figure.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces  ({\bf  left}) A example of the adaptive mesh created by \textsc  {Dendro}\nobreakspace  {}for the binary black-hole system. ({\bf  right}) the hierarchical wavelet grids generated for the binary black hole system. \relax }}{1}{figure.4}}
\newlabel{fig:bhole}{{4}{1}{({\bf left}) A example of the adaptive mesh created by \dendro ~for the binary black-hole system. ({\bf right}) the hierarchical wavelet grids generated for the binary black hole system. \relax }{figure.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces This figure illustrates the calculation of a single Runge-Kutta (RK) time step, computing the solution at the advanced time, $u_{n+1}$, from data at the previous time step, $u_{n}$. For computational efficiency, spatial and time derivatives are evaluated on equispaced blocks \textit  {(unzipped)}; a sparse grid constructed from wavelet coefficients is used for communication and to store the final solution \textit  {(zipped)}. For each RK stage $s$ we perform the \textit  {unzip} operation which results in a sequence of blocks which are used to compute the solution on the internal block (\leavevmode {\color  {green!70}$\blacksquare $}), using the padding values at the block boundary (\leavevmode {\color  {yellow!30}$\blacksquare $}) followed by a \textit  {zip} operation in between RK stages while the final update (i.e. next time step) performed using the \textit  {zip} version of the variables. Note that the re-meshing is performed as needed based on the wavelet expansion of the current solution. \relax }}{1}{figure.5}}
\newlabel{fig:overview}{{5}{1}{This figure illustrates the calculation of a single Runge-Kutta (RK) time step, computing the solution at the advanced time, $u_{n+1}$, from data at the previous time step, $u_{n}$. For computational efficiency, spatial and time derivatives are evaluated on equispaced blocks \textit {(unzipped)}; a sparse grid constructed from wavelet coefficients is used for communication and to store the final solution \textit {(zipped)}. For each RK stage $s$ we perform the \textit {unzip} operation which results in a sequence of blocks which are used to compute the solution on the internal block (\textcolor {green!70}{$\blacksquare $}), using the padding values at the block boundary (\textcolor {yellow!30}{$\blacksquare $}) followed by a \textit {zip} operation in between RK stages while the final update (i.e. next time step) performed using the \textit {zip} version of the variables. Note that the re-meshing is performed as needed based on the wavelet expansion of the current solution. \relax }{figure.5}{}}
\newlabel{eq:at_evol}{{1}{1}{}{}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces \fontsize  {20.74}{25}\selectfont  \textsc  {TreeSearch}\nobreakspace  {} performs the traversal in a top-down order over the set of keys, while flagging $k_2,k_4,k_5$ at the level $1$ split, $k_3$ at level $2$ split, and $k_1$ at level $3$ split. \relax }}{1}{figure.6}}
\newlabel{fig:sfcSearch}{{6}{1}{\small \tsearch ~ performs the traversal in a top-down order over the set of keys, while flagging $k_2,k_4,k_5$ at the level $1$ split, $k_3$ at level $2$ split, and $k_1$ at level $3$ split. \relax }{figure.6}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Comparison of \texttt  {std::bsearch} with operator $<$ and comparison free \textsc  {TreeSearch}\nobreakspace  {} approach for performing, varying number of keys on $33M$ sorted octree in \href  {https://portal.tacc.utexas.edu/user-guides/stampede2}{Stampede2}\nobreakspace  {} \texttt  {SKX} node.\relax }}{1}{figure.7}}
\newlabel{fig::balcomparison}{{7}{1}{Comparison of \texttt {std::bsearch} with operator $<$ and comparison free \tsearch ~ approach for performing, varying number of keys on $33M$ sorted octree in \Stampede ~ \texttt {SKX} node.\relax }{figure.7}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces  A simplistic example of octree to block decomposition and \textit  {unzip}\nobreakspace  {} operation. The leftmost figure shows the considering adaptive octree with \textit  {shared octant nodes}\nobreakspace  {} and its block decomposition is shown in the middle. Note that the given octree is decomposed into four regular blocks of different sizes. The rightmost figure shows the decomposed blocks padded with values coming from neighboring octants with interpolation if needed. In order to perform \textit  {unzip}\nobreakspace  {} operation both $\psi $ and $\psi $ mappings are used. \relax }}{1}{figure.8}}
\newlabel{fig:unzip}{{8}{1}{A simplistic example of octree to block decomposition and \unzip ~ operation. The leftmost figure shows the considering adaptive octree with \cgn ~ and its block decomposition is shown in the middle. Note that the given octree is decomposed into four regular blocks of different sizes. The rightmost figure shows the decomposed blocks padded with values coming from neighboring octants with interpolation if needed. In order to perform \unzip ~ operation both $\psi $ and $\psi $ mappings are used. \relax }{figure.8}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Time step snapshots of a $z$ plane slice of $3D$ \textsc  {NLSM}\nobreakspace  {} with two initial Gaussian distributions with Runge-Kutta time stepping scheme. Note that how the mesh refines (based on the WAMR) as the waves propagate away from the origin. \relax }}{1}{figure.9}}
\newlabel{fig:nlsmB}{{9}{1}{Time step snapshots of a $z$ plane slice of $3D$ \NLSM ~ with two initial Gaussian distributions with Runge-Kutta time stepping scheme. Note that how the mesh refines (based on the WAMR) as the waves propagate away from the origin. \relax }{figure.9}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Slice of the BSSNKO\nobreakspace  {} variable $\chi $ along the $z$-plane for equal mass ratio binary black holes. Above simulation performed in TACC's \href  {https://portal.tacc.utexas.edu/user-guides/stampede2}{Stampede2}\nobreakspace  {} using $1K$ cores with total simulation run time of $48hrs$ from the beginning to the merger event. \relax }}{1}{figure.10}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces Slice of the BSSNKO\nobreakspace  {} variable $\chi $ along the $z$-plane for mass ratio $q=10$ binary black holes.\relax }}{1}{figure.11}}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces Slice of the BSSNKO\nobreakspace  {} variable $\chi $ along the $z$-plane for mass ratio $q=100$ binary black holes.\relax }}{1}{figure.12}}
