\subsection{Getting and Compiling \dendro~}

The \dendro\ simulation code is freely available at GitHub (\href{https://github.com/paralab/Dendro-GR}{https://github.com/paralab/Dendro-GR}) under the MIT License. 
The latest version of the code can be obtained by cloning the repository
\begin{lstlisting}[basicstyle=\small,language=bash]
$ git clone git@github.com:paralab/Dendro-GR.git
\end{lstlisting}

The following dependencies are required to compile \dendro~
\begin{itemize}
	\item C/C++ compilers with C++11 standards and OpenMP support
	\item MPI implementation (e.g. openmpi, mvapich2 )
	\item ZLib compression library (used to write \texttt{.vtu} files in binary format with compression enabled)
	\item BLAS and LAPACK are optional and not needed for current version of \dendro~
	\item CMake 2.8 or higher version
\end{itemize}

\textbf{Note}: We have tested the compilation and execution of \dendro\ with \texttt{intel}, \texttt{gcc} 4.8 or higher, \texttt{openmpi}, \texttt{mpich2} and \texttt{intelmpi} and \texttt{craympi} (in \Titan) using the linux operating systems. 

To compile the code, execute these commands
\begin{lstlisting}[language=bash]
$ cd <path to DENDRO directory >
$ mkdir build
$ cd build
$ ccmake ../     
\end{lstlisting}
The following options for \dendro\  can then be set in cmake:
\begin{itemize}
	\item \texttt{DENDRO\_COMPUTE\_CONSTRAINTS} : Enables the computation of Hamiltonian and momentum constraints
	\item \texttt{DENDRO\_CONSEC\_COMM\_SELECT}  : If \texttt{ON} sub-communicators are selected from consecrative global ranks, otherwise sub-communicators are selected complete binary tree of global ranks (note that in this case global communicator size need to a power of 2).
	\item \texttt{DENDRO\_ENABLE\_VTU\_CONSTRAINT\_OUT} : Enables constraint variable output \linebreak while time-stepping 
	\item \texttt{DENDRO\_ENABLE\_VTU\_OUTPUT} : Enables evolution variable output while time-stepping
	\item \texttt{DENDRO\_VTK\_BINARY} : If \texttt{ON} vtu files are written in binary format, else ASCII format (binary format recommended).
	\item \texttt{DENDRO\_VTK\_ZLIB\_COMPRES} : If \texttt{ON} binary format is compressed (only effective if \texttt{DENDRO\_VTK\_BINARY} is \texttt{ON})
	\item \texttt{HILBERT\_ORDERING} : Hilbert SFC used if \texttt{ON}, otherwise Morton curve is used. (Hilbert curve is recommended to reduce the communication cost.)
	\item \texttt{NUM\_NPES\_THRESHOLD} : When running in large scale set this to $\sqrt{p}$ where $p$ number of mpi tasks for better performance.
	\item \texttt{RK\_SOLVER\_OVERLAP\_COMM\_AND\_COM} : If \texttt{ON} non blocking communication is used and enable overlapping of communication and computation \textit{unzip} (recommended option), otherwise blocking synchronized \textit{unzip} is used.  	
\end{itemize}

After configuring \dendro, generate the Makefile (use \texttt{c} to configure and \texttt{g} to generate). Then execute \texttt{make all} to build all the targets.  On completion, \bsolver~will be the main executable as related to this paper. 

\subsection{Getting Started: Running \bsolver}

\bsolver\  can be run as follows. 
\begin{lstlisting}[language=bash]
$ mpirun -np <number of mpi tasks>\
 ./bssnSolver \
<parameter file name>.par
\end{lstlisting}
Example parameter files can be found in \texttt{BSSN\_GR/pars/}. The following 
is an example parameter file for equal mass ratio binary inspirals. 
\begin{lstlisting}[basicstyle=\tiny]
	{
	"DENDRO_VERSION": 5.0,
	"BSSN_RESTORE_SOLVER":0,
	"BSSN_IO_OUTPUT_FREQ": 10,
	"BSSN_REMESH_TEST_FREQ": 5,
	"BSSN_CHECKPT_FREQ": 50,
	"BSSN_VTU_FILE_PREFIX": "bssn_gr",
	"BSSN_CHKPT_FILE_PREFIX": "bssn_cp",
	"BSSN_PROFILE_FILE_PREFIX": "bssn_r1",
	"BSSN_DENDRO_GRAIN_SZ": 100,
	"BSSN_ASYNC_COMM_K": 4,
	"BSSN_DENDRO_AMR_FAC": 1e0,
	"BSSN_WAVELET_TOL": 1e-4,
	"BSSN_LOAD_IMB_TOL": 1e-1,
	"BSSN_RK_TIME_BEGIN": 0,
	"BSSN_RK_TIME_END": 1000,
	"BSSN_RK_TIME_STEP_SIZE": 0.01,
	"BSSN_DIM": 3,
	"BSSN_MAXDEPTH": 12,
	"ETA_CONST": 2.0,
	"ETA_R0": 30.0,
	"ETA_DAMPING": 1.0,
	"ETA_DAMPING_EXP": 1.0,
	"BSSN_LAMBDA": {
	"BSSN_LAMBDA_1": 1,
	"BSSN_LAMBDA_2": 1,
	"BSSN_LAMBDA_3": 1,
	"BSSN_LAMBDA_4": 1
	},
	"BSSN_LAMBDA_F": {
	"BSSN_LAMBDA_F0": 1.0,
	"BSSN_LAMBDA_F1": 0.0
	},
	"CHI_FLOOR": 1e-4,
	"BSSN_TRK0": 0.0,
	"KO_DISS_SIGMA": 1e-1,
	"BSSN_BH1": {
	"MASS":0.48528137423856954,
	"X": 4.00000000e+00,
	"Y":0.0,
	"Z": 1.41421356e-05,
	"V_X": -0.00132697,
	"V_Y": 0.1123844,
	"V_Z": 0,
	"SPIN": 0,
	"SPIN_THETA":0,
	"SPIN_PHI": 0
	},
	"BSSN_BH2": {
	"MASS":0.48528137423856954,
	"X":-4.00000000e+00,
	"Y":0.0,
	"Z":1.41421356e-05,
	"V_X": 0.00132697,
	"V_Y": -0.1123844,
	"V_Z": 0,
	"SPIN": 0,
	"SPIN_THETA":0,
	"SPIN_PHI": 0
	}
	}
\end{lstlisting}
Here we list the key options for \bsolver\ with a short description.
\begin{itemize}
\item \texttt{BSSN\_RESTORE\_SOLVER} : Set $1$ to restore $RK$ solver from latest checkpoint. 
\item \texttt{BSSN\_IO\_OUTPUT\_FREQ} : IO (i.e. \texttt{vtu} files) output frequency
\item \texttt{BSSN\_CHECKPT\_FREQ} : Checkpoint file output frequency
\item \texttt{BSSN\_REMESH\_TEST\_FREQ} : Remesh test frequency (i.e. frequency in time steps that is being tested for re-meshing) 
\item \texttt{BSSN\_DENDRO\_GRAIN\_SZ} : Number of octants per core 
\item \texttt{BSSN\_ASYNC\_COMM\_K} : Number of variables that are being processed during an asynchronous \textit{unzip} ($<24$)
\item \texttt{BSSN\_DENDRO\_AMR\_FAC} : Safety factor for coarsening i.e. coarsen if and only if $W_c \leq AMR\_FAC \times WAVELET\_TOL$ where $W_c$ is the computed wavelet coefficient.  
\item \texttt{BSSN\_WAVELET\_TOL} : Wavelet tolerance for WAMR. 
\item \texttt{BSSN\_MAXDEPTH} : Maximum level of refinement allowed ($\leq 30$)
\item \texttt{KO\_DISS\_SIGMA} : Kreiss-Oliger dissipation factor for \BSSN~formulation
\item \texttt{MASS} : Mass of the black hole
\item \texttt{X} : $x$ coordinate of the black hole
\item \texttt{Y} : $y$ coordinate of the black hole
\item \texttt{Z} : $z$ coordinate of the black hole
\item \texttt{V\_X} : momentum of the black hole in $x$ direction
\item \texttt{V\_Y} : momentum of the black hole in $y$ direction
\item \texttt{V\_Z} : momentum of the black hole in $z$ direction
\item \texttt{SPIN} : magnitude of the spin of the black hole
\item \texttt{SPIN\_THETA} : magnitude of the spin of the black hole along $\theta$
\item \texttt{SPIN\_PHI} : magnitude of the spin of the black hole along $\phi$
\end{itemize}

\subsubsection{Generating your own parameters}
The intial data parameters for a black hole binary depend
on the total mass ($M=m1+m2$), the mass ratio $q$ and the separation distance $d$. These parameters are calculated  using the python script \texttt{BSSN\_GR/scripts/id.py}. The command to generate parameters for $q=10$, total mass $M=5$ and separation $d=16$ is 
\begin{lstlisting}
$ python3 id.py -M 5 -r 10 16
\end{lstlisting}
\begin{lstlisting}[basicstyle=\tiny]
----------------------------------------------------------------
PUNCTURE PARAMETERS (par file foramt)
----------------------------------------------------------------
"BSSN_BH1": {
"MASS":4.489529,
"X":1.454545,
"Y":0.000000,
"Z": 0.000014,
"V_X": -0.020297,
"V_Y": 0.423380,
"V_Z": 0.000000,
"SPIN": 0.000000,
"SPIN_THETA":0.000000,
"SPIN_PHI": 0.000000
},
"BSSN_BH2": {
"MASS":0.398620,
"X":-14.545455,
"Y":0.000000,
"Z":0.000014,
"V_X": 0.020297,
"V_Y": -0.423380,
"V_Z": 0.000000,
"SPIN": 0.000000,
"SPIN_THETA":0.000000,
"SPIN_PHI": 0.000000
}
The tangential momentum is just an estimate, and the value for a
for a circular orbit is likely between (0.5472794147860968, 0.29947988193805547)
\end{lstlisting}

\subsection{Symbolic interface and code generation}
The \BSSN~formulation is a decomposition of the Einstein equations into 
24 coupled hyperbolic PDEs. Writing the computation code for the 
\BSSN~formulation can be a tedious task. Hence we have written a symbolic 
python interface to generate optimized C code to compute the \BSSN~equations. 
All the symbolic utilities necessary to write the \BSSN~formulation in symbolic 
python can be found in \texttt{GR/rhs\_scripts/bssn/dendro.py} and the symbolic \BSSN~code can 
be found in \texttt{GR/rhs\_scripts/bssn/bssn.py}. 
This could be modified for more advanced uses of the code such as including
new equations to describe additional physics or for introducing a different 
formulation of the Einstein equations.

\subsection{Profiling the code}
\dendro\ contains built-in profiler code which enables one to profile the 
code extensively. On configuration, a user can enable/disable 
the internal profiling flags using \texttt{ENABLE\_DENDRO\_PROFILE\_COUNTERS} 
and the profile output can be changed between a human readable version and a 
tab separated format using the flag \texttt{BSSN\_PROFILE\_HUMAN\_READABLE}.
Note that in order to profile communication, internal profile flags need to 
be enabled. The following is an example of profiling output for the first 
10 time steps. 
\begin{lstlisting}[basicstyle=\tiny]
active npes : 16
global npes : 16
current step : 10
partition tol : 0.1
wavelet tol : 0.0001
maxdepth : 12
Elements : 4656
DOF(zip) : 279521
DOF(unzip) : 2078609
============ MESH =================
step                 min(#)    mean(#)    max(#)                        
ghost Elements       634       824.062    1065                          
local Elements       263       291        319                           
ghost Nodes          43781     55671.7    71693                         
local Nodes          14292     17470.1    20705                         
send Nodes           18760     24872.9    36861                         
recv Nodes           18113     24872.9    33777                         
========== RUNTIME =================
step                 min(s)    mean(s)    max(s)                        
++2:1 balance        0         0          0                             
++mesh               1.9753    1.98299    1.98946                       
++rkstep             20.159    20.1856    20.1996                       
++ghostExchge.       1.81442   3.15703    4.49568                       
++unzip_sync         8.27839   9.67293    11.0991                       
++unzip_async        0         0          0                             
++isReMesh           0.04642   0.117357   0.207305                      
++gridTransfer       1.53709   1.54899    1.56531                       
++deriv              1.98942   2.34851    2.76695                       
++compute_rhs        4.00119   4.61547    5.11566                       
--compute_rhs_a      0.0137962 0.0245449  0.0351532                     
--compute_rhs_b      0.0296426 0.0503471  0.069537                      
--compute_rhs_gt     0.111898  0.12846    0.15463                       
--compute_rhs_chi    0.0170642 0.0315392  0.044856                      
--compute_rhs_At     2.40738   2.72922    3.05622                       
--compute_rhs_K      0.358215  0.39879    0.457139                      
--compute_rhs_Gt     0.774211  0.933581   1.05702                       
--compute_rhs_B      0.0575426 0.071209   0.0855094                     
++boundary con       0         0.0421986  0.134712                      
++zip                0.23529   0.260862   0.291513                      
++vtu                0.0872362 0.101362   0.128246                      
++checkpoint         3.27e-06  3.85e-06   5.7469e-06     
\end{lstlisting}

\subsection{Visualizing the data}
\dendro\  can be configured to output parallel unstructured grid files in 
binary file format (\texttt{.pvtu}).   
These files can be visualized using any visualization tool which supports 
VTK file formats. All the images presented in this paper used Paraview 
due to its robustness and scalability. Paraview allows python based 
scripting to perform \texttt{pvbatch} visualization, an example pvpython 
script can be found in \texttt{scripts/bssnVis.py}

