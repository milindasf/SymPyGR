\documentclass[10pt, conference]{IEEEtran} %compsocconf

\input{preamble1}

\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Massively Parallel Simulations of Binary Black Hole Intermediate-Mass-Ratio Inspirals}


\author{\IEEEauthorblockN{Milinda Fernando(student)\IEEEauthorrefmark{1},
Hari Sundar (advisor)\IEEEauthorrefmark{2}, David Neilsen \IEEEauthorrefmark{3}, Hyun Lim \IEEEauthorrefmark{4} and Eric Hirschmann \IEEEauthorrefmark{5} }
\IEEEauthorblockA{
%School of Computing,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Department of Physics,\\
%University of Utah, ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Brigham Young University,\\
%Salt Lake City, Utah, ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Provo, Utah\\
\IEEEauthorrefmark{1}milinda@cs.utah.edu,
\IEEEauthorrefmark{2}hari@cs.utah.edu,
\IEEEauthorrefmark{3}david.neilsen@byu.edu,
\IEEEauthorrefmark{4}hyun.lim@byu.edu,
\IEEEauthorrefmark{5}ehirsch@physics.byu.edu,
}}

%\author{\IEEEauthorblockN{Milinda Fernando (student)}
%\IEEEauthorblockA{School of Computing,\\
% University of Utah\\
% Salt Lake City, Utah\\
% Email: milinda@cs.utah.edu}
% \and
% \IEEEauthorblockN{David Nielsen}
% \IEEEauthorblockA{ Department of Physics, \\
% Brigham Young University\\
% Provo, Utah\\
% Email: david.nielsen@byu.edu}
% \and
% \IEEEauthorblockN{Hari Sundar (advisor)}
% \IEEEauthorblockA{School of Computing,\\
% University of Utah\\
% Salt Lake City, Utah\\
% Email: hari@cs.utah.edu}
% }

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3}, 
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}
% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}
% make the title area
\maketitle


%\begin{abstract}
%We present a portable and highly-scalable algorithm and framework that
%targets problems in the astrophysics and numerical relativity
%communities. 
%This framework combines 
%together the parallel \dendro~ octree with wavelet adaptive 
%multiresolution and a physics module to solve the Einstein equations of 
%general relativity in the \BSSN~formulation.
%%Wavelet adaptive multiresolution is used to provide local, 
%%fine-grain adaptivity, based on the fast wavelet transform of interpolating
%%wavelets.
%The goal of this work is to perform advanced, massively parallel 
%numerical simulations of Intermediate Mass Ratio Inspirals (IMRIs)
%of binary black holes with mass ratios on the order of 100:1. These studies
%will be used to 
%generate waveforms for use in LIGO data analysis and to calibrate
%semi-analytical approximate methods. This advanced framework is designed 
%to easily accommodate many existing algorithms in astrophysics
%for 
%%compressible 
%plasma dynamics and radiation hydrodynamics. 
%We have designed novel algorithms to enable efficient simulations for such 
%experiments and demonstrate 
%excellent weak scalability up to $131K$ cores on ORNL's Titan for binary mergers for mass ratios up to $100$. 
%
%
%\end{abstract}

%\begin{IEEEkeywords}
% Numerical Relativity; Einstein equations; Adaptive Mesh Refinement; Finite Differencing; Wavelet Adaptive Multiresolution
%\end{IEEEkeywords}

% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle

\section{Introduction}
We present a portable and highly-scalable framework (\dendrogr~) that targets problems in the astrophysics and numerical relativity communities.
%\dendrogr~ consists of a parallel octree wavelet adaptive  multiresolution (WAMR) module, SymPy based symbolic code generation module and a physics module generated by the symbolic code generation module to solve the Einstein equations of general relativity in the \BSSN~formulation. 
The recent detection of Gravitational Waves (GW) has revolutionized  multi-messenger astronomy and produced several exciting discoveries. Current GW observations have been limited to observations of binary mergers of roughly equal mass. This has to a large part been due to the inability of existing computational relativity codes to simulate Intermediate Mass Ratio Inspirals (IMRIs) with a mass-ratio ($q$) greater than 10. Our approach, \dendrogr~ framework is able to simulate IMRIs with mass ratio as high as $q=100$.
%In this work we present a new highly adaptive \& scalable computational relativity framework, \dendrogr, that is able to simulate IMRIs with mass ratio as high as $q=100$. 
We have designed novel scalable algorithms to enable efficient simulations for such experiments and demonstrate excellent weak scalability up to $131K$ cores on ORNL's Titan for binary mergers for mass ratios up to $100$. 

%The goal of this work is to perform advanced, massively parallel numerical simulations of Intermediate Mass Ratio Inspirals (IMRIs) of binary black holes with mass ratios on the order of 100:1. 





%These studies will be used to generate waveforms for use in LIGO data analysis and to calibrate semi-analytical approximate methods. This advanced framework is designed to easily accommodate many existing algorithms in astrophysics for plasma dynamics and radiation hydrodynamics.
 


\noindent The key \ul{contributions} of this work include:
%\begin{enumerate}
%    \item

\vspace{0.1in}    
\noindent \textbf{Wavelet Adaptive GR}. 
To the best of our knowledge, the other comparable codes use simple models of adaptivity, i.e.,structured adaptivity, block adaptivity, or logically uniform grids \cite{EINSTEIN_TOOLKIT,Neilsen:2014hha,Bruegmann:2006at,Yamamoto:2008js}. We present a novel computational GR framework (\dendrogr)  which uses octree-based Adaptive Multiresolution(AMR) grids, where the adaptivity is determined by wavelet expansion \cite{Vasilyev1995,Vasilyev1996,Paolucci1,Paolucci2,Holmstrom1999} of the functions represented in the underlying grid. We refer this as Wavelet Adaptive Multiresolution (WAMR). This is the first \ul{highly adaptive} computational fully relativistic---i.e., including the full Einstein equations---code with an arbitrary localized 
adaptive mesh. For example for a mass ratio of $q=1$, we use approximately \texttt{7x} fewer degrees of freedom for the same accuracy compared to the block adaptivity (via Carpet \cite{CARPET}).

%\item
\noindent \textbf{Automatic symbolic code-generation}. Given the complexity of the Einstein equations, we have developed an automatic code generation framework for GR using \texttt{SymPy} that automatically generates architecture-optimized codes. This greatly improves code portability, use by domain scientists and the ability to add additional constraints and checks to validate the code.

%\item 
\noindent \textbf{\tsearch}. We developed a new parallel search algorithm \tsearch, to improve the efficiency of octree meshing. We also developed efficient \texttt{unzip} and \texttt{zip} operations to allow the application of the core computational kernels on small process-local regular blocks. This allows greater performance as well as greater performance portability. 
%Local calculations on regular blocks allows us to use established, existing numerical methods for the Einstein equations, and in future work, the relativistic fluid equations and radiation hydrodynamics equations.

% \item
%\noindent \textbf{Simulations}. We demonstrate the ability to scale to large mass ratios, enabling simulations and extraction of gravitational waves for mass ratios as high as $100$. 

% \item 
%\noindent \textbf{Implementation} \dendro ~is implemented in \textsc{C++} using MPI except for the automatic code generation framework which is implemented using \texttt{SymPy}. Our code is freely available at \texttt{https://github.com/paralab/Dendro-GR} under the MIT license.
% We are hoping to release our code on Github under the GNU license upon acceptance. 
% \end{enumerate}

\section{Methodology}
The Figure 3 on the poster presents an overview of our approach. 
\vspace{-0.15in}

%\begin{figure}[tbh]
%	%\centering
%	\resizebox{0.45\textwidth}{!}{
%		\begin{tikzpicture}
%		\def\xmax{18}
%		\def\xmin{0}
%		\def\ymin{0}
%		\def\ymax{6}
%		\begin{scope}
%		%\draw[very thin,step=1] (\xmin,\ymin) grid +(\xmax,\ymax);
%		%\draw[blue,thin,fill=yellow!20,fill opacity=0.7] (\xmin,\ymax-2) rectangle +(1.5,1.8) node[black,pos=.5,align=center] {\small parameter \\ file};
%		\draw[->,thick] (\xmin+0.2,3) -- (\xmin+1.5,3);
%		\node[text width=2cm] at (\xmin+1.25,3.5) {initial $u_0$};
%		\draw[line width=0.5mm,->] (\xmin+2,\ymax) -- (\xmax-1,\ymax) node[anchor=south east] {$t$};
%		\end{scope}
%		\begin{scope}[xshift=2cm,yshift=2.5cm]
%		\node[anchor=south west,inner sep=0] at (0,0) {\includegraphics[width=2cm]{figs/gr_init1_r1.png}};
%		\end{scope}
%		%\begin{scope}[xshift=2cm,yshift=0.25cm]
%		%\node[anchor=south west,inner sep=0] at (0,0) {\includegraphics[width=2cm]{figs/gr_init_r1.png}};
%		%\end{scope}0.0078
%		\begin{scope}[xshift=2cm,yshift=0.25cm,scale=0.03]
%		\input{fig_tex/gr_init1_r1}
%		\end{scope}
%		
%		\begin{scope}[xshift=5cm,yshift=1.75cm,scale=1.4]
%		\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		\end{scope}
%		\begin{scope}[xshift=5cm,yshift=3.25cm,scale=1.4]
%		\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		\draw[black,very thin,step=0.25cm] (0.25,0.25) grid +(0.5,0.5);
%		\end{scope}
%		%\begin{scope}[xshift=5cm,yshift=3.25cm,scale=1.4]
%		%\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		%(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		%\draw[black,very thin,step=0.125cm] (0.25,0.25) grid +(0.5,0.5);
%		%\end{scope}
%		
%		\begin{scope}[xshift=6.75cm,yshift=1.75cm,scale=1.4]
%		\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		\draw[black,ultra thin,step=0.125cm] (0.25,0.25) grid +(0.5,0.5);
%		\end{scope}
%		\begin{scope}[xshift=6.75cm,yshift=3.25cm,scale=1.4]
%		\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		\draw[black,ultra thin,step=0.0625cm] (0.25,0.25) grid +(0.5,0.5);
%		\end{scope}
%		%\begin{scope}[xshift=6.75cm,yshift=3.25cm,scale=1.4]
%		%\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		%(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		%\draw[black,ultra thin,step=0.015625cm] (0.25,0.25) grid +(0.5,0.5);
%		%\end{scope}
%		
%		
%		\begin{scope}[xshift=9.5cm,yshift=1.75cm,scale=1.4]
%		\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		\draw[black,very thin,,fill=green!70] (0.25,0.25) rectangle +(0.5,0.5);
%		\end{scope}
%		\begin{scope}[xshift=9.5cm,yshift=3.25cm,scale=1.4]
%		\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		\draw[black,very thin,,fill=green!70,step=0.25cm] (0.25,0.25) grid +(0.5,0.5) rectangle(0.25,0.25);
%		\end{scope}
%		%\begin{scope}[xshift=9.5cm,yshift=3.25cm,scale=1.4]
%		%\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		%(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		%\draw[black,very thin,,fill=green!70,step=0.125cm] (0.25,0.25) grid +(0.5,0.5) rectangle(0.25,0.25);
%		%\end{scope}
%		
%		\begin{scope}[xshift=11.25cm,yshift=1.75cm,scale=1.4]
%		\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		\draw[black,very thin,,fill=green!70,step=0.125cm] (0.25,0.25) grid +(0.5,0.5) rectangle(0.25,0.25);
%		\end{scope}
%		\begin{scope}[xshift=11.25cm,yshift=3.25cm,scale=1.4]
%		\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		\draw[black,very thin,,fill=green!70,step=0.0625cm] (0.25,0.25) grid +(0.5,0.5)rectangle(0.25,0.25);
%		\end{scope}
%		%\begin{scope}[xshift=11.25cm,yshift=3.25cm,scale=1.4]
%		%\draw[thin,fill=yellow!30] (0,0)--(0,1)--(1,1)--(1,0)--cycle
%		%(0.25,0.25)--(0.75,0.25)--(0.75,0.75)--(0.25,0.75)--cycle;
%		%\draw[black,very thin,,fill=green!70,step=0.015625cm] (0.25,0.25) grid +(0.5,0.5)rectangle(0.25,0.25);
%		%\end{scope}
%		
%		\begin{scope}[xshift=13.5cm,yshift=2.5cm]
%		\node[anchor=south west,inner sep=0] at (0,0) {\includegraphics[width=2cm]{figs/gr_im1_r1.png}};
%		\end{scope}
%		%\begin{scope}[xshift=13.5cm,yshift=0.25cm]
%		%\node[anchor=south west,inner sep=0] at (0,0) {\includegraphics[width=2cm]{figs/gr_im_r1.png}};
%		%\end{scope}
%		
%		\begin{scope}[xshift=8cm,yshift=0.0cm,scale=0.025]
%		\input{fig_tex/gr_init1_r1}
%		\end{scope}
%		
%		\begin{scope}[xshift=13.5cm,yshift=0.25cm,scale=0.03]
%		\input{fig_tex/gr_im1_r1}
%		\end{scope}
%		
%		%\path [blue,fill=cyan,line width=0.5mm,->,bend right,every node/.style={black,sloped,anchor=south,auto=false}] (0.75,4.0) edge node{\textit{initial } $u$} (2,2.3);
%		\path [blue,fill=cyan,line width=0.5mm,->,every node/.style={black,sloped,anchor=south,auto=false}] (4.0,2.3) edge node{\textit{\ unzip}} (5,3.25);
%		\path [blue,fill=cyan,line width=0.5mm,->,bend left,every node/.style={black,sloped,anchor=south,auto=false}] (6.5,4.75) edge node {\textit{RK stages}}(11.125,4.75);
%		\path [blue,fill=cyan,line width=0.5mm,->,bend left,every node/.style={black,sloped,anchor=south,auto=false}] (11.125,1.75) edge node{\textit{\ zip}} (9.5,0.75);
%		\path [blue,fill=cyan,line width=0.5mm,->,bend left,every node/.style={black,sloped,anchor=south,auto=false}] (8,0.75) edge  node{\textit{\ unzip}}(6.5,1.75);
%		\path [blue,fill=cyan,line width=0.5mm,->,every node/.style={black,sloped,anchor=south,auto=false}] (12.75,3.25) edge  node{\textit{zip\ \ \ \ \ }}(13.5,2.25);
%		\node[text width=0.5cm] at (3,4.75)  {$u_n$};
%		\node[text width=0.5cm] at (14.5,4.75)  {$u_{n+1}$};
%		\node[text width=2cm] at (6,1.5)  {\textit{blocks}};
%		\end{tikzpicture}
%	}
%	\caption{\small This figure illustrates the calculation of a single Runge-Kutta (RK) time step, computing the solution at next time step, $u_{n+1}$, 
%		using the previous time step, $u_{n}$. All the derivatives are evaluated on equispaced blocks \textit{(unzipped)}; a sparse grid constructed from wavelet coefficients is used
%		for communication and to store the final solution \textit{(zipped)}. For each RK stage $s$ we perform the \textit{unzip} operation which results in a sequence of blocks which are used to compute the solution on the internal block (\textcolor{green!70}{$\blacksquare$}), using the padding values at the block boundary (\textcolor{yellow!30}{$\blacksquare$}) followed by a \textit{zip} operation in between RK stages while the final update (i.e. next time step)  performed using the \textit{zip} version of the variables. Note that the re-meshing is performed as needed based on the wavelet expansion of the current solution.  \label{fig:overview}}
%\end{figure}

%\subsection{Octree partitioning, construction \& 2:1 balancing }
%In this work we use octree based adaptive grids, where the adaptivity is determined by wavelet coefficients of the solution represented. We use our previous work on Space Filling Curve(SFC) based flexible octree partitioning algorithm \tsort\cite{Fernando:2017} to perform parallel octree partitioning. We refer \emph{octree construction} as completion of an incomplete octree which is performed by top down traversal over the octant based on the SFC ordering specified. We impose 2:1 balancing constraint by using a similar approach to \cite{SundarSampathBiros08} which enforces that for any given octant in the octree, all its neighboring octant differ by refinement level $\leq 1$ . The 2:1 balancing constraint makes the subsequent steps such as mesh generation, \unzip~ \& \zip~ operations simpler. 

\subsection{\tsearch: Efficient search operations on octrees}
By \emph{mesh generation} we refer to the process of building data structures required to perform numerical computations on a topological 2:1 balanced complete octree. 
%We need to perform ghost/halo octant exchange across the processors such that neighborhood information lies on other processors locally available for each processor after the exchange. 
We build two additional data structures referred as octant to octant (\oTo)~\& octant to nodal(\oTn) maps. \oTo~ contains neighborhood information at an octant level (i.e. neighbor octants of a given octant), while \oTn~ contains for a given octant its corresponding nodes. In order to build those maps, we need to perform search operations on the adaptive octree. The state-of-the-art approaches \cite{mantle} uses SFC based ordering operator combined with binary searches. The key drawback of this approach is random, unstructured memory accesses leading to bad memory performances especially the octree size is significantly large. Assuming we need to search $k$ keys on size $n$ octree, the time complexity for binary search approach would be $\mathcal{O}(k\log(n))$. In our approach \tsearch~ we start with the root node, perform bucketing for each key to the corresponding child if root and recurse until we hit a leaf octant(see Figure \ref{fig:sfcSearch}). The time complexity of \tsearch~ can be written as $\mathcal{O}(k\log(n))$, which is similar to the binary search approach, but \tsearch~ approach perform $k\log(n)$ streaming passes compared to random accesses leading to better memory performances. 
	
\begin{figure}[tbh]
	\resizebox{0.48\textwidth}{!}{
		\begin{tikzpicture}[scale=0.21, every node/.style={scale=0.9}]
		
		% \draw[gray, very thin] (0,0) grid +(8,8);
		
		
		\begin{scope}[shift={(0,0)}]
		\draw (0,0) rectangle +(8,8);
		\draw[step=4] (0,0) grid +(8,8);
		\draw[step=2] (0,4) grid +(4,4);
		\draw[step=2] (4,0) grid +(4,4);
		\draw[step=1] (2,6) grid +(2,2);
		
		\draw[fill=red!60] (3.8,7.7) rectangle +(0.2,0.2);
		\node at (4.5,7.0) {\small $k_1$};
		\draw[fill=red!60] (6,6) rectangle +(0.2,0.2);
		\node at (6,5.5) {\small $k_2$};
		\draw[fill=red!60] (7,3) rectangle +(0.2,0.2);
		\node at (7,2.5) {\small $k_3$};
		\draw[fill=red!60] (2,2) rectangle +(0.2,0.2);
		\node at (2.0,1.5) {\small $k_4$};
		\draw[fill=red!60] (3,3) rectangle +(0.2,0.2);
		\node at (3.0,2.5) {\small $k_5$};
		
		\end{scope}	 	
		
		\begin{scope}[shift={(11,0)}]
		\draw (0,0) rectangle +(8,8);
		\draw[step=4,cpu4] (0,0) grid +(8,8);
		
		\node at (0.5,0.5) {\small $1$};
		\node at (4.5,0.5) {\small $4$};
		\node at (0.5,4.5) {\small $7$};
		\node at (4.5,4.5) {\small $1$};
		
		\draw[fill=red!60] (3.8,7.7) rectangle +(0.2,0.2);
		\node at (4.5,7.0) {\small $k_1$};
		\draw[fill=red!60] (6,6) rectangle +(0.2,0.2);
		\node at (6,5.5) {\small $k_2$};
		\draw[fill=red!60] (7,3) rectangle +(0.2,0.2);
		\node at (7,2.5) {\small $k_3$};
		\draw[fill=red!60] (2,2) rectangle +(0.2,0.2);
		\node at (2.0,1.5) {\small $k_4$};
		\draw[fill=red!60] (3,3) rectangle +(0.2,0.2);
		\node at (3.0,2.5) {\small $k_5$};
		
		\end{scope}
		
		\begin{scope}[shift={(22,0)}]
		\draw (0,0) rectangle +(8,8);
		\draw[step=4,cpu4] (0,0) grid +(8,8);
		\draw[step=2,cpu3] (0,4) grid +(4,4);
		\draw[step=2,cpu3] (4,0) grid +(4,4);
		\node at (0.5,0.5) {\small $1$};
		
		\node at (4.5,0.5) {\small $1$};
		\node at (6.5,0.5) {\small $1$};
		\node at (4.5,2.5) {\small $1$};
		\node at (6.5,2.5) {\small $1$};
		
		\node at (0.5,4.5) {\small $1$};
		\node at (2.5,4.5) {\small $1$};
		\node at (0.5,6.5) {\small $1$};
		\node at (2.5,6.5) {\small $4$};
		
		\node at (4.5,4.5) {\small $1$};	
		
		\draw[fill=red!60] (3.8,7.7) rectangle +(0.2,0.2);
		\node at (4.5,7.0) {\small $k_1$};
		\draw[fill=red!60] (6,6) rectangle +(0.2,0.2);
		\node at (6,5.5) {\small $k_2$};
		\draw[fill=red!60] (7,3) rectangle +(0.2,0.2);
		\node at (7.5,2.5) {\small $k_3$};
		\draw[fill=red!60] (2,2) rectangle +(0.2,0.2);
		\node at (2.0,1.5) {\small $k_4$};
		\draw[fill=red!60] (3,3) rectangle +(0.2,0.2);
		\node at (3.0,2.5) {\small $k_5$};
		\end{scope}
		
		\begin{scope}[shift={(33,0)}]
		\draw (0,0) rectangle +(8,8);
		\draw[step=4,cpu4] (0,0) grid +(8,8);
		\draw[step=2,cpu3] (0,4) grid +(4,4);
		\draw[step=2,cpu3] (4,0) grid +(4,4);
		\draw[step=1,cpu1] (2,6) grid +(2,2);
		
		\node at (0.5,0.5) {\small $1$};
		
		\node at (4.5,0.5) {\small $1$};
		\node at (6.5,0.5) {\small $1$};
		\node at (4.5,2.5) {\small $1$};
		\node at (6.5,2.5) {\small $1$};
		
		\node at (0.5,4.5) {\small $1$};
		\node at (2.5,4.5) {\small $1$};
		\node at (0.5,6.5) {\small $1$};
		
		\node at (2.5,6.5) {\small $1$};
		\node at (3.5,6.5) {\small $1$};
		\node at (2.5,7.5) {\small $1$};
		\node at (3.5,7.5) {\small $1$};
		
		\node at (4.5,4.5) {\small $1$};		
		
		
		\draw[fill=red!60] (3.8,7.7) rectangle +(0.2,0.2);
		\node at (4.5,7.0) {\small $k_1$};
		\draw[fill=red!60] (6,6) rectangle +(0.2,0.2);
		\node at (6,5.5) {\small $k_2$};
		\draw[fill=red!60] (7,3) rectangle +(0.2,0.2);
		\node at (7.5,2.5) {\small $k_3$};
		\draw[fill=red!60] (2,2) rectangle +(0.2,0.2);
		\node at (2.0,1.5) {\small $k_4$};
		\draw[fill=red!60] (3,3) rectangle +(0.2,0.2);
		\node at (3.0,2.5) {\small $k_5$};
		
		\end{scope}
		\end{tikzpicture}
	}
	\caption{\label{fig:sfcSearch}\small For a given ordered octree $\tau$  and a set of keys (leftmost figure), \tsearch~ performs the traversal in a top-down order over the set of keys, while flagging $k_2,k_4,k_5$ at the level $1$ split, $k_3$ at level $2$ split, and $k_1$ at level $3$ split. %Note that numbers inside the octants (i.e. bucket count) represent the number of octants in $\tau$ belongs to that bucket at splitting level $l$. When bucket count of octant $e\in \tau$ reaches $1$, all the keys in that bucket flagged as found and $e$ is considered to be the search result for those keys. 
	}
	\vspace{-0.15in}
\end{figure}

\subsection{\unzip~ \& \zip : Finite difference computations on adaptive grids}
\label{sec:unzip_and_zip}
The main objective of the \unzip~ and \zip~ operations is to enable stencil computations on adaptive octrees. Any adaptive octree can be considered as a union of regular sub-octrees which we referred  as blocks or \emph{octree to block decomposition}. To perform stencil computations on these blocks, it is required to have neighborhood region surrounding the block which referred as \emph{padding}. The block with surrounding  padding region is referred as \unzip~ representation(see Figure 6 on the poster). The stencil and other update operations are only performed on the block as the padding is read-only. At the end of the update, the simulation variables are {\em zipped} back, i.e., injected back to the {\em zipped} representation. Note that several key operations such as RK update \& inter-process communications operate using the \textit{zip} representation, and are efficient (see Figure 3 on the poster ).  








%\begin{algorithm}
%	\caption{\small Overview of our approach}\label{alg:overview}
%	\footnotesize
%	\begin{algorithmic}[1]
%		%\Require A list of points or regions $W$, the starting level $l_1$ and the ending level $l_2$, $K_{oct}$
%		%\Ensure $\tau_c$ \- ordered complete octree based on $W$
%		%\Function{TreeSort($W$, $l_1$, $l_2$)}{}
%		\State $M \leftarrow$ initialize mesh \Comment{meshing}
%		\State $u \leftarrow$ initialize variables $(M)$
%		\While{$t < T$}
%		\For{$r = 1:3$} \Comment{Runge-Kutta stages}
%		\State $B, \hat{u} \leftarrow \text{Unzip}(M, u)$ \Comment{\S\ref{sec:unzip_and_zip}}
%		\For{$ b \in B$} 
%		\State Compute derivatives \Comment Machine generated code 
%		\State Compute $\hat{u}_{rhs}(b)$ \Comment Machine generated code 
%		\EndFor % blocks
%		\State $u_{rhs} \leftarrow \text{Zip}(M, B, \hat{u}_{rhs})$ \Comment{\S\ref{sec:unzip_and_zip}}
%		\State RK update
%		\EndFor  % rk 
%		\State $t\leftarrow t+dt$
%		\If{need remesh $M$}  \Comment{remesh }
%		\State $M' \leftarrow$ remesh($M$) 
%		\State $u' \leftarrow$ Intergid\_Transfer$(M, M', u)$ \Comment{inter-grid transfer}
%		\EndIf
%		\EndWhile  % time
%	\end{algorithmic}
%\end{algorithm}


\subsection{Symbolic interface and code generation}
The Einstein equations are a set of non-linear, coupled, partial 
differential equations. On discretization, one can end up with 24 or 
more equations with thousands of terms. Writing, optimizing and maintaining 
code for this is very challenging. Sustainability and keeping it relevant for new 
architectural changes are additional difficulties. To address these issues, we 
have developed a symbolic interface to \dendrogr. We leverage symbolic python 
(\texttt{SymPy}) as the backend for this along with the python package 
\texttt{cog} to embed python code within our application-level \texttt{C++} 
code(see symbolic code generation on the poster).

%The \texttt{\dendro\_sym} package allows us to write the discretized 
%versions of the equations similar to how they are written mathematically 
%and enable improved usability for non-computational scientists. 


%\subsection{Numerical Methods}
%\label{sec:nm}
%In this section we briefly outline our particular choices for 
%solving these equations. We write the \BSSN\ equations in terms of the conformal 
%factor $\chi$. We use the parameterization of the
%``$1+\log$'' slicing condition and the $\Gamma$-driver shift.
%Spatial derivatives are calculated using finite difference operators that are ${\rm O}(h^4)$ in the grid spacing, $h$, 
%with upwind derivatives for some Lie derivative terms. 
%%We calculate derivatives for the Ricci tensor and enforce the algebraic
%%constraints as described in~\cite{Bruegmann:2006at}. 
%Outgoing radiative boundary conditions are applied to each \BSSN\ function.
%The BSSN equations are integrated in time using an explicit Runge-Kutta (RK)
%scheme. The solution at each point is integrated
%with a single global times step, that is set by the smallest grid spacing
%and the Courant condition.
%The tests in this paper were done 
%using third order RK with Courant factor $\lambda=0.1$. 
%Kreiss-Oliger dissipation is added~\cite{kodissipation,Alcubierre:1138167} 
%to the solution to eliminate high-frequency noise that can be generated 
%near the black hole singularities.



%\begin{figure}[H]
%	\centering
%	\resizebox{0.4\textwidth}{!}{
%		\begin{tikzpicture}[scale=0.2,every node/.style={scale=0.6}]
%		
%		\begin{scope}[shift={(0,0)}]
%		\draw[step=5cm] (0,0) grid +(10,10);
%		\draw[step=2.5cm] (5,0) grid +(5,5);
%		\draw[step=2.5cm] (0,5) grid +(5,5);
%		
%		\def \r{0.12}
%		\foreach \x in {0,2.5,5}{
%			\foreach \y in {0,2.5,5}{
%				\draw[red,fill=red] (\x,\y) circle (\r);
%			}
%		}
%		
%		\foreach \x in {5,7.5,10}{
%			\foreach \y in {5,7.5,10}{
%				\draw[red,fill=red] (\x,\y) circle (\r);
%			}
%		}
%		
%		\foreach \x in {0,1.25,2.5,3.75}{
%			\foreach \y in {6.25,7.5,8.75,10}{
%				\draw[blue,fill=blue] (\x,\y) circle (\r);
%			}
%		}	
%		
%		\foreach \x in {6.25,7.5,8.75,10}{
%			\foreach \y in {0,1.25,2.5,3.75}{
%				\draw[blue,fill=blue] (\x,\y) circle (\r);
%			}
%		}
%		\end{scope}
%		
%		\begin{scope}[shift={(14,0)}]
%		%\draw[cyan,thick,fill=blue!20] (-1,-1) rectangle +(6,6);
%		\draw[cyan,thick] (0,0) rectangle +(5,5);
%		\draw[cyan,thick,xshift=2cm,yshift=2.0cm] (5,5) rectangle +(5,5);
%		\draw[cyan,thick,step=2.5cm,xshift=2.0cm] (5,0) grid +(5,5);
%		\draw[cyan,thick,step=2.5cm,yshift=2.0cm] (0,5) grid +(5,5);
%		%	\draw[cyan,thick] (0,4) rectangle +(2,2);
%		%	\draw[cyan,thick] (2,4) rectangle +(2,2);
%		%	\draw[cyan,thick] (2,6) rectangle +(2,2);
%		%	\draw[cyan,thick] (4,0) rectangle +(2,2);
%		%	\draw[cyan,thick] (6,2) rectangle +(2,2);
%		%	\draw[cyan,thick] (6,0) rectangle +(2,2);
%		\end{scope}
%		
%		\begin{scope}[shift={(30,0)}]
%		\def \r{0.12}
%		\draw[cyan,fill=blue!50,fill opacity=0.5]
%		(-2,-2)--(-2,6)--(6,6)--(6,-2)--cycle
%		(0,0) -- (4,0)-- (4,4)--(0,4)--cycle;
%		\foreach \x in {-2,0,2,2,4,6}{
%			\foreach \y in {-2,0,2,2,4,6}{
%				\draw[red,fill=red] (\x,\y) circle (\r);
%			}
%		}
%		
%		\draw[cyan,thick,fill=blue!50,fill opacity=0.5,even odd rule,xshift=8.5cm,yshift=8.5cm] 
%		(-2,-2)--(-2,6)--(6,6)--(6,-2)--cycle
%		(0,0) -- (4,0)-- (4,4)--(0,4)--cycle;
%		\foreach \x in {-2,0,2,2,4,6}{
%			\foreach \y in {-2,0,2,2,4,6}{
%				\draw[red,fill=red,xshift=8.5cm,yshift=8.5cm] (\x,\y) circle (\r);
%			}
%		}
%		
%		\draw[cyan,thick,fill=blue!50,fill opacity=0.5,even odd rule,xshift=8.5cm] 
%		(-1,-1)--(-1,5)--(5,5)--(5,-1)--cycle
%		(0,0) -- (4,0)-- (4,4)--(0,4)--cycle;
%		\draw[cyan,thick,step=2,xshift=8.5cm] (0,0) grid +(4,4);
%		\foreach \x in {-1,0,1,2,3,4,5}{
%			\foreach \y in {-1,0,1,2,3,4,5}{
%				\draw[blue,fill=blue,xshift=8.5cm] (\x,\y) circle (\r);
%			}
%		}
%		
%		\draw[cyan,thick,fill=blue!50,fill opacity=0.5,even odd rule,yshift=8.5cm] 
%		(-1,-1)--(-1,5)--(5,5)--(5,-1)--cycle
%		(0,0) -- (4,0)-- (4,4)--(0,4)--cycle;
%		\draw[cyan,thick,step=2,yshift=8.5cm] (0,0) grid +(4,4);	
%		\foreach \x in {-1,0,1,2,3,4,5}{
%			\foreach \y in {-1,0,1,2,3,4,5}{
%				\draw[blue,fill=blue,yshift=8.5cm] (\x,\y) circle (\r);
%			}
%		}
%		
%		\end{scope}	
%		\end{tikzpicture}
%	}	
%	\caption{\label{fig:unzip} \small A simplistic example of octree to block decomposition and \unzip~ operation. The leftmost figure shows the considering adaptive octree with \textit{zip} state and its block decomposition is shown in the middle. The rightmost figure shows the decomposed blocks padded with values coming from neighboring octants with interpolation if needed.}
%	\vspace{-0.15in}
%\end{figure}

%\subsection{Putting everything together}
%
%We use a $3^{rd}$ order Runge-Kutta time stepper, to perform time evolution.  A given RK stage is computed by performing \unzip ~ operations with overlapped exchange of the ghost layer for the evolution variables, computation of the derivatives and right-hand-side (rhs) (using the code generated by the symbolic framework) for all local blocks and finally performing \zip~ operation to get the computed {\em zipped} rhs variables. The RK update is then performed on the {\em zipped} variables. An complete outline of our approach for simulating binary BH mergers demonstrating how the various components come together is listed in Algorithm \ref{alg:overview} and illustrated in Figure \ref{fig:overview}.
\vspace{-0.15in}
\section{Results}
In this section, we present results on scalability studies performed on \dendrogr~ (see Figures \ref{fig:ss_r10} \& \ref{fig:ws_g1000}) and comparison study with the \ET (see Figure \ref{fig:et_sans_adaptivity}) which also provides an insight on the efficiency of WAMR grid compared to structured/block adaptivity. We also present a comparison study between \tsearch~ \& binary search approach (see Figure 5 on the poster ). 

%\begin{figure}[tbh]
%	\centering
%	\begin{tikzpicture}
%	\begin{axis}[legend pos= north west,xlabel={number of keys $\rightarrow$},symbolic x coords={100,1K,10K,100K,1M,10M,20M,33M,64M},
%	xtick={data},
%	ylabel={time(s) $\rightarrow$},grid=major,width=9cm,height=4cm]
%	\addplot [sq_b1,thin,mark=*]table [x={numKeys},y={bsearch_time_s}]{dat/stampede2/tsearch.dat};
%	\addplot [sq_r1,thin,mark=x] table [x={numKeys},y={tsearch_time_s}]{dat/stampede2/tsearch.dat};
%	\legend{\texttt{std::bsearch}, \tsearch }
%	\end{axis}
%	\end{tikzpicture}
%	\caption{Comparison of \texttt{std::bsearch} with partial ordering operator $<$ and comparison free \tsearch~ approach for performing, varying number of keys on $33M$ sorted complete octree using single core in \Stampede~ \texttt{SKX} node.}
%	\label{fig::balcomparison}
%\end{figure}

\begin{figure}[tbh]
	\centering
	\includegraphics[width=0.3\textwidth]{plots/strong_r10}
	\caption{\small Strong scaling results in ORNL's \Titan~for a single RK step (averaged over 10 steps) with derivative computation (\texttt{deriv}), right hand side( {\texttt rhs}) computation, \texttt{unzip} cost 
		and communication cost (\texttt{comm}) for a fixed problem size of $10.5B$ unknowns where the number of cores ranging from $4,096$ to $65,536$ cores on $4096$ nodes. Note that for strong scaling results re-meshing is disabled in order to keep the problem size fixed.  \label{fig:ss_r10} }
	\vspace{-0.2in}
\end{figure}

\begin{figure}[tbh]
	\centering
	\includegraphics[width=0.8\columnwidth]{plots/weak_r10}
	\caption{\small Weak scaling results in ORNL's \Titan~for  $RK/(dof/p)$ (averaged over 10 steps) where $RK,dof,p$ denotes the time for single $RK$ step, degrees of freedom, and number of cores respectively, where the approximate grain size of 1.536M unknowns where the number of cores ranging from $32$ to $131,072$ cores on $8192$ nodes where the largest problem having $206$ Billion unknowns. \label{fig:ws_g1000} 
		%Above results are generated with mass ratio $\mu=10$ with \maxDepth~ 18 and wavelet tolerance of $10^{-6}$ \label{fig:ws_g1000} 
	}
	\vspace{-0.1in}
\end{figure}

\begin{figure}[tbh]
  \centering
\resizebox{0.9\columnwidth}{!}{
	\begin{tikzpicture}[scale=0.8]
	\begin{axis}[
	ylabel={time per $RK$ step (s) $\rightarrow$},
	% xlabel={number of cores $\rightarrow$},
	legend pos=north west,symbolic x coords={48,96,192,384,768,1536,3072},xtick = data,
	height=3.38in,
	width=3.38in,
	%extra x tick style={tick label style={black, below, yshift=1.5ex}},
	xticklabels=\empty,
	ticklabel style={left}, grid=major, 
	extra x ticks={48,96,192,384,768,1536,3072},
	extra x tick labels={48,96,192,384,768,1536,3072},
	extra x tick style={tick label style={black, below, yshift=0.5ex}},
	legend style={at={(0.5,1.05)},anchor=south},
	%yticklabels=\empty,
	%extra y tick style={yticklabel style={xshift=1cm, anchor=west}}
	]
	\addplot[thick,sq_b1,smooth,mark options={scale=0.8}]  table [x={npes},y ={rkstep}]{dat/stampede2/et_ss_4M.dat};
	\addplot[thick,sq_g1,smooth,mark options={scale=0.8}]  table [x={npes},y ={rkstep}]{dat/stampede2/dendro_ss_4M.dat};
	
	\addplot[thick,sq_b2,opacity=0.6,smooth]  table [x={npes},y ={rkstep_ws_3}]{dat/stampede2/et_ws_2K.dat};
	\addplot[thick,sq_g2,opacity=0.6,smooth]  table [x={npes},y ={rkstep_ws_3}]{dat/stampede2/dendro_ws_2K.dat};
	\legend{\small \ET(strong scaling), \dendrogr(strong scaling), \ET(weak scaling), \dendrogr(weak scaling) }
	
	\end{axis}
	
	\begin{scope}[xshift=-2.5cm]
	% dendro
	%table grid
	\draw (-7,0) grid +(7,7);
	% weak scaling highlight
	\draw[fill=sq_g1, opacity=0.3] (-6-1,0) rectangle +(1,1);
	\draw[fill=sq_g1, opacity=0.3] (-5-1,1) rectangle +(1,1);
	\draw[fill=sq_g1, opacity=0.3] (-4-1,2) rectangle +(1,1);
	\draw[fill=sq_g1, opacity=0.3] (-3-1,3) rectangle +(1,1);
	\draw[fill=sq_g1, opacity=0.3] (-2-1,4) rectangle +(1,1);
	\draw[fill=sq_g1, opacity=0.3] (-1-1,5) rectangle +(1,1);
	\draw[fill=sq_g1, opacity=0.3] (-1,6) rectangle +(1,1);
	
	% strong scaling highlight
	\draw[fill=sq_g1, opacity=0.5, sq_g1] (-6.01-1,3) rectangle +(6.02+1,1);
	
	% data - dendro
	%                 48                                       96                                          192                                           384                                768                                 1536	3072
	\node at (-5.5-1,0.5) {\scriptsize $0.83$}; \node at (-4.5-1,0.5) {\scriptsize $0.55$}; \node at (-3.5-1,0.5) {\scriptsize $0.37$}; \node at (-2.5-1,0.5) {\scriptsize $-$}; \node at (-1.5-1,0.5) {\scriptsize $-$}; \node at (-0.5-1,0.5) {\scriptsize $-$}; \node at (-0.5,0.5) {\scriptsize $-$}; % 500K
	\node at (-5.5-1,1.5) {\scriptsize $1.58$}; \node at (-4.5-1,1.5) {\scriptsize $0.86$}; \node at (-3.5-1,1.5) {\scriptsize $0.51$}; \node at (-2.5-1,1.5) {\scriptsize $0.35$}; \node at (-1.5-1,1.5) {\scriptsize $-$}; \node at (-0.5-1,1.5) {\scriptsize $-$};  \node at (-0.5,1.5) {\scriptsize $-$};% 1M
	\node at (-5.5-1,2.5) {\scriptsize $2.98$}; \node at (-4.5-1,2.5) {\scriptsize $1.57$}; \node at (-3.5-1,2.5) {\scriptsize $0.83$}; \node at (-2.5-1,2.5) {\scriptsize $0.61$}; \node at (-1.5-1,2.5) {\scriptsize $0.38$}; \node at (-0.5-1,2.5) {\scriptsize $-$}; \node at (-0.5,2.5) {\scriptsize $-$};% 2M
	\node at (-5.5-1,3.5) {\scriptsize $5.90$};    \node at (-4.5-1,3.5) {\scriptsize $3.35$}; \node at (-3.5-1,3.5) {\scriptsize $1.75$}; \node at (-2.5-1,3.5) {\scriptsize $1.04$}; \node at (-1.5-1,3.5) {\scriptsize $0.54$}; \node at (-0.5-1,3.5) {\scriptsize $0.39$}; \node at (-0.5,3.5) {\scriptsize $-$}; % 4M
	\node at (-5.5-1,4.5) {\scriptsize $11.23$};    \node at (-4.5-1,4.5) {\scriptsize $6.59$};    \node at (-3.5-1,4.5) {\scriptsize $3.67$}; \node at (-2.5-1,4.5) {\scriptsize $1.92$}; \node at (-1.5-1,4.5) {\scriptsize $1.10$}; \node at (-0.5-1,4.5) {\scriptsize $0.69$}; \node at (-0.5,4.5) {\scriptsize $0.38$};% 8M
	\node at (-5.5-1,5.5) {\scriptsize $19.22$};    \node at (-4.5-1,5.5) {\scriptsize $11.08$};    \node at (-3.5-1,5.5) {\scriptsize $6.22$};    \node at (-2.5-1,5.5) {\scriptsize $3.20$}; \node at (-1.5-1,5.5) {\scriptsize $1.64$}; \node at (-0.5-1,5.5) {\scriptsize $0.98$}; \node at (-0.5,5.5) {\scriptsize $0.56$};% 16M
	\node at (-5.5-1,6.5) {\scriptsize $35.46$};    \node at (-4.5-1,6.5) {\scriptsize $-$};    \node at (-3.5-1,6.5) {\scriptsize $12.34$};    \node at (-2.5-1,6.5) {\scriptsize $6.88$};    \node at (-1.5-1,6.5) {\scriptsize $4.01$}; \node at (-0.5-1,6.5) {\scriptsize $2.06$};  \node at (-0.5,6.5) {\scriptsize $1.06$};% 32M
	
	\node at (-5.5-1,-0.25) {\scriptsize $48$};
	\node at (-4.5-1,-0.25) {\scriptsize $96$};
	\node at (-3.5-1,-0.25) {\scriptsize $192$};
	\node at (-2.5-1,-0.25) {\scriptsize $384$};
	\node at (-1.5-1,-0.25) {\scriptsize $768$};
	\node at (-0.5-1,-0.25) {\scriptsize $1536$};
	\node at (-0.5,-0.25)   {\scriptsize $3072$};
	
	
	\draw[-latex'] (-6.25-1,6.75) -- (-6.25-1,7.25); \node at (-6.75-1, 7) {\scriptsize dofs};  \node at (-6.75-1, 7.35) {\scriptsize total};
	
	\node at (-6.6-1,6.5) {\scriptsize $768M$};
	\node at (-6.6-1,5.5) {\scriptsize $384M$};
	\node at (-6.6-1,4.5) {\scriptsize $192M$};
	\node at (-6.6-1,3.5) {\scriptsize $96M$};
	\node at (-6.6-1,2.5) {\scriptsize $48M$};
	\node at (-6.6-1,1.5) {\scriptsize $24M$};
	\node at (-6.6-1,0.5) {\scriptsize $12M$};
	
	\draw[-latex'] (0,-0.25) -- (0.75,-0.25); \node at (1.0, 0) {\scriptsize cores};
	
	\draw[-latex'] (-1,7.3) -- (-1,7.8);   \node at (0, 7.5) {\scriptsize per core};  \node at (0, 8) {\scriptsize dofs (along the diagonal) };    
	
	\draw[-latex'] (0.25,7.25) -- (-0.25,6.75); \node at (0.75,7) {\scriptsize $250K$};
	\draw[-latex'] (0.25,6.25) -- (-0.25,5.75); \node at (0.75,6) {\scriptsize $125K$};
	\draw[-latex'] (0.25,5.25) -- (-0.25,4.75); \node at (0.75,5) {\scriptsize $62K$};
	\draw[-latex'] (0.25,4.25) -- (-0.25,3.75); \node at (0.75,4) {\scriptsize $31K$};
	\draw[-latex'] (0.25,3.25) -- (-0.25,2.75); \node at (0.75,3) {\scriptsize $15K$};
	\draw[-latex'] (0.25,2.25) -- (-0.25,1.75); \node at (0.75,2) {\scriptsize $8K$};
	\draw[-latex'] (0.25,1.25) -- (-0.25,0.75); \node at (0.75,1) {\scriptsize $4K$};
	
	\node at (-4, 9) {\dendrogr};
	
	
	
	\end{scope}
	
	\begin{scope}[xshift=2.5cm]
	% ET
	% table grid
	\draw (7,0) grid +(7,7);
	% weak highlight 
	\draw[fill=sq_b1, opacity=0.3] (7,0) rectangle +(1,1);
	\draw[fill=sq_b1, opacity=0.3] (8,1) rectangle +(1,1);
	\draw[fill=sq_b1, opacity=0.3] (9,2) rectangle +(1,1);
	\draw[fill=sq_b1, opacity=0.3] (10,3) rectangle +(1,1);
	\draw[fill=sq_b1, opacity=0.3] (11,4) rectangle +(1,1);
	\draw[fill=sq_b1, opacity=0.3] (12,5) rectangle +(1,1);
	\draw[fill=sq_b1, opacity=0.3] (12,5) rectangle +(1,1);
	
	%strong highlights 
	\draw[fill=sq_b1, opacity=0.5, sq_b1] (6.99,3) rectangle +(6.02+1,1);
	
	% data - ET 
	%                 48                                       96                                          192                                           384                                768                                 1536 
	\node at (7.5,0.5) {\scriptsize $2.27$}; \node at (8.5,0.5) {\scriptsize $2.06$}; \node at (9.5,0.5) {\scriptsize $1.93$}; \node at (10.5,0.5) {\scriptsize $1.88$}; \node at (11.5,0.5) {\scriptsize $2.03$}; \node at (12.5,0.5) {\scriptsize $2.07$}; \node at (13.5,0.5) {\scriptsize $-$};% 500K
	\node at (7.5,1.5) {\scriptsize $2.67$}; \node at (8.5,1.5) {\scriptsize $2.31$}; \node at (9.5,1.5) {\scriptsize $2.08$}; \node at (10.5,1.5) {\scriptsize $1.94$}; \node at (11.5,1.5) {\scriptsize $2.07$}; \node at (12.5,1.5) {\scriptsize $2.04$}; \node at (13.5,1.5) {\scriptsize $-$}; % 1M
	\node at (7.5,2.5) {\scriptsize $3.36$}; \node at (8.5,2.5) {\scriptsize $2.68$}; \node at (9.5,2.5) {\scriptsize $2.31$}; \node at (10.5,2.5) {\scriptsize $2.08$}; \node at (11.5,2.5) {\scriptsize $2.12$}; \node at (12.5,2.5) {\scriptsize $2.08$}; \node at (13.5,2.5) {\scriptsize $-$};% 2M
	\node at (7.5,3.5) {\scriptsize $4.68$};    \node at (8.5,3.5) {\scriptsize $3.46$}; \node at (9.5,3.5) {\scriptsize $2.69$}; \node at (10.5,3.5) {\scriptsize $2.32$}; \node at (11.5,3.5) {\scriptsize $3.45$}; \node at (12.5,3.5) {\scriptsize $2.16$}; \node at (13.5,3.5) {\scriptsize $-$}; % 4M
	\node at (7.5,4.5) {\scriptsize $7.13$};    \node at (8.5,4.5) {\scriptsize $4.76$};    \node at (9.5,4.5) {\scriptsize $3.45$}; \node at (10.5,4.5) {\scriptsize $2.74$}; \node at (11.5,4.5) {\scriptsize $2.51$}; \node at (12.5,4.5) {\scriptsize $2.31$}; \node at (13.5,4.5) {\scriptsize $-$}; % 8M
	\node at (7.5,5.5) {\scriptsize $12.44$};    \node at (8.5,5.5) {\scriptsize $7.51$};    \node at (9.5,5.5) {\scriptsize $4.87$};    \node at (10.5,5.5) {\scriptsize $3.48$}; \node at (11.5,5.5) {\scriptsize $2.92$}; \node at (12.5,5.5) {\scriptsize $2.52$}; \node at (13.5,5.5) {\scriptsize $-$};% 16M
	\node at (7.5,6.5) {\scriptsize $23.38$};    \node at (8.5,6.5) {\scriptsize $12.65$};    \node at (9.5,6.5) {\scriptsize $7.64$};    \node at (10.5,6.5) {\scriptsize $4.93$};    \node at (11.5,6.5) {\scriptsize $3.71$}; \node at (12.5,6.5) {\scriptsize $2.95$}; \node at (13.5,6.5) {\scriptsize $-$};% 32M    
	
	\node at (7.5,-0.25) {\scriptsize $48$};
	\node at (8.5,-0.25) {\scriptsize $96$};
	\node at (9.5,-0.25) {\scriptsize $192$};
	\node at (10.5,-0.25) {\scriptsize $384$};
	\node at (11.5,-0.25) {\scriptsize $768$};
	\node at (12.5,-0.25) {\scriptsize $1536$};
	\node at (13.5,-0.25) {\scriptsize $3072$};
	
	\draw[-latex'] (13+1,-0.25) -- (14+1,-0.25); \node at (13.5+1, 0) {\scriptsize cores};
	
	\draw[-latex'] (6.75,6.75) -- (6.75,7.25); \node at (6.25, 7) {\scriptsize dofs};  \node at (6.25, 7.35) {\scriptsize total};
	
	\node at (7.25-1,6.5) {\scriptsize $768M$};
	\node at (7.25-1,5.5) {\scriptsize $384M$};
	\node at (7.25-1,4.5) {\scriptsize $192M$};
	\node at (7.25-1,3.5) {\scriptsize $96M$};
	\node at (7.25-1,2.5) {\scriptsize $48M$};
	\node at (7.25-1,1.5) {\scriptsize $24M$};
	\node at (7.25-1,0.5) {\scriptsize $12M$};
	
	
	\draw[-latex'] (14,7.3) -- (14,7.8);   \node at (13+2.25, 7.5) {\scriptsize per core};  \node at (13+2.25, 8) {\scriptsize dofs (along the diagonal) };    
	%\node at (13.4, 7) {\scriptsize size};  \node at (13.5, 7.35) {\scriptsize grain};
	
	\draw[-latex'] (13.25+1,7.25) -- (12.75+1,6.75); \node at (13.75+1,7) {\scriptsize $250K$};
	\draw[-latex'] (13.25+1,6.25) -- (12.75+1,5.75); \node at (13.75+1,6) {\scriptsize $125K$};
	\draw[-latex'] (13.25+1,5.25) -- (12.75+1,4.75); \node at (13.75+1,5) {\scriptsize $62K$};
	\draw[-latex'] (13.25+1,4.25) -- (12.75+1,3.75); \node at (13.75+1,4) {\scriptsize $31K$};
	\draw[-latex'] (13.25+1,3.25) -- (12.75+1,2.75); \node at (13.75+1,3) {\scriptsize $15K$};
	\draw[-latex'] (13.25+1,2.25) -- (12.75+1,1.75); \node at (13.75+1,2) {\scriptsize $8K$};
	\draw[-latex'] (13.25+1,1.25) -- (12.75+1,0.75); \node at (13.75+1,1) {\scriptsize $4K$};
	
	\node at (11, 9) {\ET};
	
	
	\end{scope}
	
	
	
	
	
	% table 
	
	
	
	% axis
	%\node at (axis cs:64,11) [anchor=north west] {\tiny $48M$};
	
	
		
	
	
	
	\end{tikzpicture}
}
\caption{\label{fig:et_sans_adaptivity} \small Comparison between \ET~ and \dendrogr\ without factoring in adaptivity (i.e. both \ET~ \& \dendrogr~ support uniform grids.). For a fixed tolerance, we expand the domain for a $1:1$ mass-ratio simulation such that both \ET~ and \dendrogr\ have roughly the same number of dofs. We present both weak and strong scaling results using both codes. On the left table are results from \dendrogr\ and from \ET\  on the right. In the middle, we plot a representative strong and weak scaling curve for each code. The \dendrogr\  scaling is plotted in green (lighter shade for weak) and blue for \ET. The corresponding data entries are also marked in the tables. Note that the rows represent strong scaling and the diagonal entries represent weak scaling results and runtime is reported in seconds$(s)$. }
\vspace{-0.2in}
\end{figure}













%============ Conclusion ===============
%\section{Conclusion}

%In the short time that LIGO and Virgo
%have been searching for
%gravitational waves, we have already learned exciting things about
%neutron stars~\cite{Most:2018hfd,Shibata:2017xdx}, 
%the production of heavy elements 
%(such as gold)~\cite{0004-637X-855-2-99}, 
%and the population of black holes in the 
%universe~\cite{TheLIGOScientific:2016htt}. 
%When gravitational wave observations are combined with observations of
%electromagnetic radiation---from radio waves to gamma rays---there is
%a multiplicative effect that magnifies the scientific impact. This is
%the promise of multi-messenger astronomy.
%
%The full scientific
%impact of multi-messenger astronomy is only realized when the
%observations are informed by sophisticated computer models of the underlying
%astrophysical phenomena. 
%\dendro\ provides the ability to run these models in a scalable way, 
%with local adaptivity criteria using WAMR.
%While AMR codes with block-adaptivity typically lose performance as the number
%of adaptive levels increases, \dendro\ achieves impressive scalability on a real 
%application even with many levels of refinement. The combination of scalability
%and adaptivity will allow us to study the gravitational radiation from
%IMRIs without simplifying approximations in direct numerical simulations.
%
%The \dendro\ code reported on here, with 
%a module for vacuum black hole spacetimes, is just our initial step in 
%creating a highly adaptive computational platform for studying
%relativistic astrophysics on the next-generation of supercomputers.
%This work will be followed with additional modules for solving the
%relativistic magnetohydrodynamics equations, 
%nuclear equations of state, and radiation hydrodynamics.
%For application developers, a key advantage of \dendro\ is the ability to use
%conventional numerical methods for these modules.
%
%As LIGO and Virgo are joined by other gravitational wave detectors and
%observatories around the world, we expect many more exciting 
%discoveries to come.




% conference papers do not normally have an appendix


% use section* for acknowledgement
%\section*{Acknowledgment}
%The authors would like to thank...
%more thanks here
% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section
%\IEEEtriggeratref{70}
% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtran}
\bibliography{bssn}


%\newpage
%\pagebreak
%\setcounter{page}{1}
%%\appendix
%\appendices
%
%\section{Artifact Description}
%\label{sec:AD}
%\input{artifact_description}
%
%\newpage
%\pagebreak
%\setcounter{page}{1}
%\section{Artifact Evaluation}
%\label{sec:AE}
%\input{artifact_evaluation}



% that's all folks
\end{document}


