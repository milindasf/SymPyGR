//
// Based on file originally Created by milinda on 7/25/17.
/**
*@author Milinda Fernando
*School of Computing, University of Utah
*@brief Header file for the GR simulation.
*/

//

#include "nlsm.h"
#include "nlsmUtils.h"
#include "mpi.h"
#include "TreeNode.h"
#include "mesh.h"
#include <vector>
#include <iostream>
#include "rk4nlsm.h"
#include "octUtils.h"

/*[[[cog
import cog
from paramDef import namespace

cog.outl("using namespace {0};".format(namespace))

]]]*/
//[[[end]]]

int main (int argc, char** argv)
{
    if(argc<2)
        std::cout<<"Usage: "<<argv[0]<<" paramFile"<<std::endl;

    MPI_Init(&argc,&argv);
    MPI_Comm comm=MPI_COMM_WORLD;

    int rank,npes;
    MPI_Comm_rank(comm,&rank);
    MPI_Comm_size(comm,&npes);

    nlsm::timer::initFlops();

    nlsm::timer::total_runtime.start();

    //1 . read the parameter file.
    if(!rank) std::cout<<" reading parameter file :"<<argv[1]<<std::endl;
    nlsm::readParamFile(argv[1],comm);

    if(rank==1|| npes==1)
    {
		std::cout << "parameters read: " << std::endl;

		/*[[[cog
		import cog
		import paramDef as p

		for param in list(p.parameters.values()) + list(p.parameters.initialDataValues()):
			if param.isComment() or param.valueExpression is not None:
				continue

			if param.arraySize is not None:
				cog.out("std::cout<<YLW<<\"\\t{0} : (\"<<".format(param.id))
				#may want to reconsider this formatting, cout arrays on multiple lines
				for i in range(len(param.value)):
					if i > 0:
						cog.out("<<\", \"<<")
					cog.out("{0}[{1}]".format(param.id, i))
				cog.outl("<<\" )\"<<NRM<<std::endl;")
			else:
				cog.outl("std::cout<<YLW<<\"\\t{0} :\"<<{0}<<NRM<<std::endl;".format(param.id))

		]]]*/
		//[[[end]]]
    }

	_InitializeHcurve(DIM);
	m_uiMaxDepth = MAXDEPTH;
	if (NUM_VARS % ASYNC_COMM_K != 0)
	{
		if (!rank)
			std::cout << "[overlap communication error]: total NUM_VARS: " << NUM_VARS << " is not divisable by ASYNC_COMM_K: " << ASYNC_COMM_K << std::endl;
		exit(0);
	}

    //2. generate the initial grid.
    std::vector<ot::TreeNode> tmpNodes;
    std::function<void(double,double,double,double*)> f_init=[](double x,double y,double z,double*var){
		nlsm::initData(x,y,z,var);
	};

	const unsigned int interpVars = NUM_VARS;
	unsigned int varIndex[interpVars];
	for (unsigned int i = 0; i < NUM_VARS; i++)
		varIndex[i] = i;

	DendroIntL localSz, globalSz;
	double t_stat;
	double t_stat_g[3];
	timer::t_f2o.start();
	if (ENABLE_BLOCK_ADAPTIVITY)
	{
		if (!rank) std::cout << YLW << "Using block adaptive mesh. AMR disabled " << NRM << std::endl;

		const Point pt_min(BLK_MIN_X, BLK_MIN_Y, BLK_MIN_Z);
		const Point pt_max(BLK_MAX_X, BLK_MAX_Y, BLK_MAX_Z);
		blockAdaptiveOctree(tmpNodes, pt_min, pt_max, m_uiMaxDepth - 2, m_uiMaxDepth, comm);
	}
	else
	{
		if (!rank) std::cout << YLW << "Using function2Octree. AMR enabled " << NRM << std::endl;

		function2Octree(f_init, NUM_VARS, REFINE_VARIABLE_INDICES, NUM_REFINE_VARS, tmpNodes, m_uiMaxDepth, RK_MIN_TOL, ELE_ORDER, comm);
		std::cout << "f2o else end" << std::endl;
	}
	timer::t_f2o.stop();

    t_stat=nlsm::timer::t_f2o.seconds;
    par::Mpi_Reduce(&t_stat,t_stat_g,1,MPI_MIN,0,comm);
    par::Mpi_Reduce(&t_stat,t_stat_g+1,1,MPI_SUM,0,comm);
    par::Mpi_Reduce(&t_stat,t_stat_g+2,1,MPI_MAX,0,comm);
    t_stat_g[1]=t_stat_g[1]/(double)npes;

    localSz=tmpNodes.size();
    par::Mpi_Reduce(&localSz,&globalSz,1,MPI_SUM,0,comm);

    if(!rank) std::cout<<GRN<<" function to octree max (s): "<<t_stat_g[2]<<NRM<<std::endl;
    if(!rank) std::cout<<GRN<<" function to octree # octants : "<<globalSz<<NRM<<std::endl;

    par::Mpi_Bcast(&globalSz,1,0,comm);

	const unsigned int grainSz = DENDRO_GRAIN_SZ;

    bool isActive;
    MPI_Comm commActive;
    const int p_npes_prev=binOp::getPrevHighestPowerOfTwo((globalSz/grainSz));
    const int p_npes_next=binOp::getNextHighestPowerOfTwo((globalSz/grainSz));

    int p_npes=globalSz/grainSz;
    (std::abs(p_npes_prev-p_npes)<=std::abs(p_npes_next-p_npes)) ? p_npes=p_npes_prev : p_npes=p_npes_next;

    if(p_npes>npes) p_npes=npes;
    // quick fix to enforce the npes>=2 for any given grain size.
    if(p_npes<=1 && npes>1) p_npes=2;

    if(p_npes==npes)
    {
        MPI_Comm_dup(comm,&commActive);
        isActive=true;

    }
	else
    {
        //isActive=(rank*grainSz<globalSz);
        isActive=isRankSelected(npes,rank,p_npes);
        par::splitComm2way(isActive,&commActive,comm);

    }

	shrinkOrExpandOctree(tmpNodes, LOAD_IMB_TOL, DENDRO_DEFAULT_SF_K, isActive, commActive, comm);

    if(!isActive)
        if(tmpNodes.size()!=0)
            std::cout<<" rank_g: "<<rank<<" isActive: "<<isActive<<" f2O octants: "<<tmpNodes.size()<<std::endl;

    std::vector<ot::TreeNode> balOct;
    localSz=0;
    if(isActive)
    {
        int rank_active,npes_active;

        MPI_Comm_size(commActive,&npes_active);
        MPI_Comm_rank(commActive,&rank_active);

        if(!rank_active) std::cout<<"[MPI_COMM_SWITCH]: "<<npes_active<<std::endl;

		ot::TreeNode root(DIM, MAXDEPTH);
		std::vector<ot::TreeNode> tmpVec;
		timer::t_cons.start();

		SFC::parSort::SFC_treeSort(tmpNodes, tmpVec, tmpVec, tmpVec, LOAD_IMB_TOL, m_uiMaxDepth, root, ROOT_ROTATION, 1, TS_REMOVE_DUPLICATES, SPLIT_FIX, commActive);
		std::swap(tmpNodes, tmpVec);
		tmpVec.clear();

		SFC::parSort::SFC_treeSort(tmpNodes, tmpVec, tmpVec, tmpVec, LOAD_IMB_TOL, m_uiMaxDepth, root, ROOT_ROTATION, 1, TS_CONSTRUCT_OCTREE, SPLIT_FIX, commActive);
		std::swap(tmpNodes, tmpVec);
		tmpVec.clear();

        timer::t_cons.stop();
        t_stat=timer::t_cons.seconds;

        par::Mpi_Reduce(&t_stat,t_stat_g,1,MPI_MIN,0,commActive);
        par::Mpi_Reduce(&t_stat,t_stat_g+1,1,MPI_SUM,0,commActive);
        par::Mpi_Reduce(&t_stat,t_stat_g+2,1,MPI_MAX,0,commActive);
        t_stat_g[1]=t_stat_g[1]/(double)rank_active;

        localSz=tmpNodes.size();
        par::Mpi_Reduce(&localSz,&globalSz,1,MPI_SUM,0,commActive);

        if(!rank_active) std::cout<<GRN<<"remove duplicates + octree construction (s): "<<t_stat_g[2]<<NRM<<std::endl;
        if(!rank_active) std::cout<<GRN<<" # const. octants: "<<globalSz<<NRM<<std::endl;

		timer::t_bal.start();

		SFC::parSort::SFC_treeSort(tmpNodes, balOct, balOct, balOct, LOAD_IMB_TOL, m_uiMaxDepth, root, ROOT_ROTATION, 1, TS_BALANCE_OCTREE, SPLIT_FIX, commActive);
		tmpNodes.clear();

		timer::t_bal.stop();
		t_stat = timer::t_bal.seconds;

        par::Mpi_Reduce(&t_stat,t_stat_g,1,MPI_MIN,0,commActive);
        par::Mpi_Reduce(&t_stat,t_stat_g+1,1,MPI_SUM,0,commActive);
        par::Mpi_Reduce(&t_stat,t_stat_g+2,1,MPI_MAX,0,commActive);
        t_stat_g[1]=t_stat_g[1]/(double)rank_active;

        if(!rank_active) std::cout<<GRN<<" 2:1 balancing max (s): "<<t_stat_g[2]<<NRM<<std::endl;
        localSz=balOct.size();
    }
    MPI_Comm_free(&commActive);

    // all reduce act as barrier to sync all procs.
    par::Mpi_Allreduce(&localSz,&globalSz,1,MPI_SUM,comm);
    if(!rank) std::cout<<GRN<<" balanced # octants : "<<globalSz<<NRM<<std::endl;

    timer::t_mesh.start();

    ot::Mesh* mesh = new ot::Mesh(balOct, 1, ELE_ORDER, comm, true, ot::SM_TYPE::FDM, DENDRO_GRAIN_SZ, LOAD_IMB_TOL, SPLIT_FIX);

    timer::t_mesh.stop();
    t_stat = timer::t_mesh.seconds;

    par::Mpi_Reduce(&t_stat,t_stat_g,1,MPI_MIN,0,comm);
    par::Mpi_Reduce(&t_stat,t_stat_g+1,1,MPI_SUM,0,comm);
    par::Mpi_Reduce(&t_stat,t_stat_g+2,1,MPI_MAX,0,comm);
    t_stat_g[1]=t_stat_g[1]/(double)npes;

    localSz=mesh->getNumLocalMeshNodes();
    par::Mpi_Reduce(&localSz,&globalSz,1,MPI_SUM,0,comm);
    if(!rank) std::cout<<GRN<<" # of CG nodes (vertices) : "<<globalSz<<NRM<<std::endl;
    if(!rank)
    {
        std::cout<< GRN<<"Mesh generation time (max): "<<t_stat_g[2]<<NRM<<std::endl;
        std::cout<<"\t"<<GRN<<" e2e (min,mean,max): "<<"( "<<t_e2e_g[0]<<"\t"<<t_e2e_g[1]<<"\t"<<t_e2e_g[2]<<" )"<<NRM<<std::endl;
        std::cout<<"\t"<<GRN<<" e2n (min,mean,max): "<<"( "<<t_e2n_g[0]<<"\t"<<t_e2n_g[1]<<"\t"<<t_e2n_g[2]<<" )"<<NRM<<std::endl;
        std::cout<<"\t"<<GRN<<" sm (min,mean,max): "<<"( "<<t_sm_g[0]<<"\t"<<t_sm_g[1]<<"\t"<<t_sm_g[2]<<" )"<<NRM<<std::endl;
        std::cout<<"\t"<<GRN<<" blk (min,mean,max): "<<"( "<<t_blk_g[0]<<"\t"<<t_blk_g[1]<<"\t"<<t_blk_g[2]<<" )"<<NRM<<std::endl;
    }

    ode::solver::RK4_NLSM rk_nlsm(mesh, RK45_TIME_BEGIN, RK45_TIME_END, RK45_TIME_STEP_SIZE);
    if (RESTORE_SOLVER == 1)
        rk_nlsm.restoreCheckPoint(CHKPT_FILE_PREFIX.c_str(), comm);

    timer::t_rkSolve.start();
    rk_nlsm.rkSolve();
    timer::t_rkSolve.stop();
    timer::total_runtime.stop();

    rk_nlsm.freeMesh();
    //nlsm::timer::profileInfo(nlsm::NLSM_PROFILE_FILE_PREFIX.c_str(),mesh);
    //delete mesh;
    MPI_Finalize();

    return 0;
}
