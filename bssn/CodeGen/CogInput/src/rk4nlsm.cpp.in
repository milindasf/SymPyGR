//
// Created by milinda on 12/1/17.
/**
*@author Milinda Fernando
*School of Computing, University of Utah
*@brief
*/
//

#include "rk4nlsm.h"

namespace ode
{
    namespace solver
    {

        RK4_NLSM::RK4_NLSM(ot::Mesh *pMesh, double pTBegin, double pTEnd,double pTh): RK(pMesh,pTBegin,pTEnd,pTh)
        {

			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("//allocate memory for variables")
			cog.outl("m_uiVar=new double*[{0}::NUM_VARS];".format(namespace))
			cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++){{".format(namespace))
			cog.outl("\tm_uiVar[index]=m_uiMesh->createVector<double>();")
			cog.outl("}\n")

			cog.outl("m_uiPrevVar=new double*[{0}::NUM_VARS];".format(namespace))
			cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)\n{{".format(namespace))
			cog.outl("\tm_uiPrevVar[index]=m_uiMesh->createVector<double>();")
			cog.outl("}\n")

			cog.outl("m_uiVarIm=new double*[{0}::NUM_VARS];".format(namespace))
			cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)\n{{".format(namespace))
			cog.outl("m_uiVarIm[index]=m_uiMesh->createVector<double>();")
			cog.outl("}\n")

			cog.outl("m_uiStage=new double**[{0}::RK4_STAGES];".format(namespace))
			cog.outl("for(unsigned int stage=0;stage<{0}::RK4_STAGES;stage++)\n{{".format(namespace))
			cog.outl("\tm_uiStage[stage]=new double*[{0}::NUM_VARS];".format(namespace))
			cog.outl("\tfor(unsigned int index=0;index<{0}::NUM_VARS;index++)\n\t{{".format(namespace))
			cog.outl("\t\tm_uiStage[stage][index]=m_uiMesh->createVector<double>();")
			cog.outl("\t}\n}\n")

			cog.outl("m_uiUnzipVar=new double*[{0}::NUM_VARS];".format(namespace))
			cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)\n{{".format(namespace))
			cog.outl("\tm_uiUnzipVar[index]=m_uiMesh->createUnZippedVector<double>();")
			cog.outl("}\n")

			cog.outl("m_uiUnzipVarRHS=new double*[{0}::NUM_VARS];".format(namespace))
			cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)\n{{".format(namespace))
			cog.outl("\tm_uiUnzipVarRHS[index]=m_uiMesh->createUnZippedVector<double>();")
			cog.outl("}\n")

			cog.outl("//mpi communication")
			cog.outl("m_uiSendNodeBuf=new double*[{0}::ASYNC_COMM_K];".format(namespace))
			cog.outl("m_uiRecvNodeBuf=new double*[{0}::ASYNC_COMM_K];".format(namespace))
			cog.outl("m_uiSendReqs=new MPI_Request*[{0}::ASYNC_COMM_K];".format(namespace))
			cog.outl("m_uiRecvReqs=new MPI_Request*[{0}::ASYNC_COMM_K];".format(namespace))
			cog.outl("m_uiSendSts=new MPI_Status*[{0}::ASYNC_COMM_K];".format(namespace))
			cog.outl("m_uiRecvSts=new MPI_Status*[{0}::ASYNC_COMM_K];\n".format(namespace))

			cog.outl("for(unsigned int index=0;index<{0}::ASYNC_COMM_K;index++)\n{{".format(namespace))
			cog.outl("\tm_uiSendNodeBuf[index]=NULL;")
			cog.outl("\tm_uiRecvNodeBuf[index]=NULL;")
			cog.outl("\tm_uiSendReqs[index]=NULL;")
			cog.outl("\tm_uiRecvReqs[index]=NULL;")
			cog.outl("\tm_uiSendSts[index]=NULL;")
			cog.outl("\tm_uiRecvSts[index]=NULL;")
			cog.outl("}\n")

			]]]*/
			//[[[end]]]

            if(m_uiMesh->isActive())
            {
                // allocate mpi comm. reqs and status
				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("for(unsigned int index=0;index<{0}::ASYNC_COMM_K;index++)".format(namespace))

				]]]*/
				//[[[end]]]
                {
                    if(m_uiMesh->getGhostExcgTotalSendNodeCount()!=0) m_uiSendNodeBuf[index]=new double[m_uiMesh->getGhostExcgTotalSendNodeCount()];
                    if(m_uiMesh->getGhostExcgTotalRecvNodeCount()!=0) m_uiRecvNodeBuf[index]=new double[m_uiMesh->getGhostExcgTotalRecvNodeCount()];

                    if(m_uiMesh->getSendProcListSize()!=0)
                    {
                        m_uiSendReqs[index]=new MPI_Request[m_uiMesh->getSendProcListSize()];
                        m_uiSendSts[index]=new MPI_Status[m_uiMesh->getSendProcListSize()];
                    }

                    if(m_uiMesh->getRecvProcListSize()!=0)
                    {
                        m_uiRecvReqs[index]=new MPI_Request[m_uiMesh->getRecvProcListSize()];
                        m_uiRecvSts[index]=new MPI_Status[m_uiMesh->getRecvProcListSize()];
                    }
                }
            }
        }

        RK4_NLSM::~RK4_NLSM()
        {
			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)".format(namespace))

			]]]*/
			//[[[end]]]
            {
                delete [] m_uiVar[index];
                delete [] m_uiPrevVar[index];
                delete [] m_uiVarIm[index];
                delete [] m_uiUnzipVar[index];
                delete [] m_uiUnzipVarRHS[index];
            }

            delete [] m_uiVar;
            delete [] m_uiPrevVar;
            delete [] m_uiVarIm;
            delete [] m_uiUnzipVar;
            delete [] m_uiUnzipVarRHS;

			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("for(unsigned int stage=0;stage<{0}::RK4_STAGES;stage++)\n{{".format(namespace))
			cog.outl("\tfor(unsigned int index=0;index<{0}::NUM_VARS;index++)\n\t{{".format(namespace))
			cog.outl("\t\tdelete [] m_uiStage[stage][index];")
			cog.outl("\t}\n}\n")

			cog.outl("for(unsigned int stage=0;stage<{0}::RK4_STAGES;stage++)\n{{".format(namespace))
			cog.outl("\tdelete [] m_uiStage[stage];")
			cog.outl("}\n")
			cog.outl("delete [] m_uiStage;\n")

			cog.outl("// mpi communications")
			cog.outl("for(unsigned int index=0;index<{0}::ASYNC_COMM_K;index++)".format(namespace))
			]]]*/
			//[[[end]]]
            {
                delete [] m_uiSendNodeBuf[index];
                delete [] m_uiRecvNodeBuf[index];

                delete [] m_uiSendReqs[index];
                delete [] m_uiRecvReqs[index];

                delete [] m_uiSendSts[index];
                delete [] m_uiRecvSts[index];

            }

            delete [] m_uiSendNodeBuf;
            delete [] m_uiRecvNodeBuf;

            delete [] m_uiSendReqs;
            delete [] m_uiSendSts;
            delete [] m_uiRecvReqs;
            delete [] m_uiRecvSts;
        }

        void RK4_NLSM::applyInitialConditions(double** zipIn)
        {
            unsigned int nodeLookUp_CG;
            unsigned int nodeLookUp_DG;
            unsigned int x,y,z,len;
            const ot::TreeNode * pNodes=&(*(m_uiMesh->getAllElements().begin()));
            unsigned int ownerID,ii_x,jj_y,kk_z;
            unsigned int eleOrder=m_uiMesh->getElementOrder();
            const unsigned int * e2n_cg=&(*(m_uiMesh->getE2NMapping().begin()));
            const unsigned int * e2n_dg=&(*(m_uiMesh->getE2NMapping_DG().begin()));
            const unsigned int nPe=m_uiMesh->getNumNodesPerElement();
            const unsigned int nodeLocalBegin=m_uiMesh->getNodeLocalBegin();
            const unsigned int nodeLocalEnd=m_uiMesh->getNodeLocalEnd();

			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("double* var=new double[{0}::NUM_VARS];".format(namespace))

			]]]*/
			//[[[end]]]

            double mp, mm, mp_adm, mm_adm, E, J1, J2, J3;

            for(unsigned int elem=m_uiMesh->getElementLocalBegin();elem<m_uiMesh->getElementLocalEnd();elem++)
            {
				for (unsigned int k = 0; k < (eleOrder + 1); k++)
				{
					for (unsigned int j = 0; j < (eleOrder + 1); j++)
					{
						for (unsigned int i = 0; i < (eleOrder + 1); i++)
						{
							nodeLookUp_CG = e2n_cg[elem * nPe + k * (eleOrder + 1) * (eleOrder + 1) + j * (eleOrder + 1) + i];
							if (nodeLookUp_CG >= nodeLocalBegin && nodeLookUp_CG < nodeLocalEnd)
							{
								nodeLookUp_DG = e2n_dg[elem * nPe + k * (eleOrder + 1) * (eleOrder + 1) + j * (eleOrder + 1) + i];
								m_uiMesh->dg2eijk(nodeLookUp_DG, ownerID, ii_x, jj_y, kk_z);
								len = 1u << (m_uiMaxDepth - pNodes[ownerID].getLevel());
								x = pNodes[ownerID].getX() + ii_x * (len / (eleOrder));
								y = pNodes[ownerID].getY() + jj_y * (len / (eleOrder));
								z = pNodes[ownerID].getZ() + kk_z * (len / (eleOrder));
								assert(len % eleOrder == 0);
								/*[[[cog
								import cog
								from paramDef import namespace

								cog.outl("{0}::initData((double)x,(double)y,(double)z,var);".format(namespace))
								cog.outl("for (unsigned int v = 0; v < {0}::NUM_VARS; v++)\n{{".format(namespace))
								cog.outl("\tzipIn[v][nodeLookUp_CG] = var[v];")
								cog.outl("}")
								]]]*/
								//[[[end]]]
							}
						}
					}
				}
            }
            
            delete [] var;
        }

        void RK4_NLSM::initialGridConverge()
        {
            applyInitialConditions(m_uiPrevVar);

            bool isRefine=false;
            unsigned int oldElements,oldElements_g;
            unsigned int newElements,newElements_g;

            // refine based on all the variables
			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("const unsigned int refineNumVars={0}::NUM_REFINE_VARS;".format(namespace))
			cog.outl("unsigned int refineVarIds[refineNumVars];")

			cog.outl("for(unsigned int vIndex=0;vIndex<refineNumVars;vIndex++)\n{")
			cog.outl("\trefineVarIds[vIndex]={0}::REFINE_VARIABLE_INDICES[vIndex];".format(namespace))
			cog.outl("}\n")

			cog.outl("double minTol={0}::RK_MIN_TOL;".format(namespace))
			]]]*/
			//[[[end]]]    
            std::function<double(double,double,double)> tolFunc =[minTol](double x,double y, double z)
			{ 
				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("return {0}::computeTol(x,y,z,minTol);".format(namespace))

				]]]*/
				//[[[end]]]
			};
            unsigned int iterCount=1;
            do
            {

                #ifdef RK_SOLVER_OVERLAP_COMM_AND_COMP
                                unzipVars_async(m_uiPrevVar,m_uiUnzipVar);
                #else
                                performGhostExchangeVars(m_uiPrevVar);
                                unzipVars(m_uiPrevVar,m_uiUnzipVar);
                #endif

				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("if({0}::ENABLE_BLOCK_ADAPTIVITY)\n{{".format(namespace))
				cog.outl("\tisRefine=false;")
				cog.outl("}")
				cog.outl("else\n{")
				cog.outl("\tisRefine=m_uiMesh->isReMeshUnzip((const double **)m_uiUnzipVar,refineVarIds,refineNumVars,tolFunc,{0}::DENDRO_AMR_FAC);".format(namespace))
				cog.outl("}")
				]]]*/
				//[[[end]]]

                if(isRefine)
                {

					/*[[[cog
					import cog
					from paramDef import namespace

					cog.outl("ot::Mesh* newMesh=m_uiMesh->ReMesh({0}::DENDRO_GRAIN_SZ,{0}::LOAD_IMB_TOL,{0}::SPLIT_FIX);".format(namespace))

					]]]*/
					//[[[end]]]

                    oldElements=m_uiMesh->getNumLocalMeshElements();
                    newElements=newMesh->getNumLocalMeshElements();

                    par::Mpi_Allreduce(&oldElements,&oldElements_g,1,MPI_SUM,m_uiMesh->getMPIGlobalCommunicator());
                    par::Mpi_Allreduce(&newElements,&newElements_g,1,MPI_SUM,m_uiMesh->getMPIGlobalCommunicator());

                    if(!(m_uiMesh->getMPIRankGlobal()))std::cout<<"initial grid iteration : "<<iterCount<<" old mesh: "<<oldElements_g<<" new mesh: "<<newElements_g<<std::endl;


                    // performs the inter-grid transfer
                    intergridTransferVars(m_uiPrevVar,newMesh);


					/*[[[cog
					import cog
					from paramDef import namespace

					cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)".format(namespace))

					]]]*/
					//[[[end]]]
                    {
                        delete [] m_uiVar[index];
                        delete [] m_uiVarIm[index];
                        delete [] m_uiUnzipVar[index];
                        delete [] m_uiUnzipVarRHS[index];

                        m_uiVar[index]=NULL;
                        m_uiVarIm[index]=NULL;
                        m_uiUnzipVar[index]=NULL;
                        m_uiUnzipVarRHS[index]=NULL;

                        m_uiVar[index]=newMesh->createVector<double>();
                        m_uiVarIm[index]=newMesh->createVector<double>();
                        m_uiUnzipVar[index]=newMesh->createUnZippedVector<double>();
                        m_uiUnzipVarRHS[index]=newMesh->createUnZippedVector<double>();


                    }

					/*[[[cog
					import cog
					from paramDef import namespace

					cog.outl("for(unsigned int stage=0;stage<{0}::RK4_STAGES;stage++)\n{{".format(namespace))
					cog.outl("\tfor(unsigned int index=0;index<{0}::NUM_VARS;index++)\n\t{{".format(namespace))
					cog.outl("\t\tdelete [] m_uiStage[stage][index];")
					cog.outl("\t\tm_uiStage[stage][index]=NULL;")
					cog.outl("\t\tm_uiStage[stage][index]=newMesh->createVector<double>();")
					cog.outl("\t}\n}")
					]]]*/
					//[[[end]]]

                    std::swap(newMesh,m_uiMesh);
                    delete newMesh;

                    #ifdef RK_SOLVER_OVERLAP_COMM_AND_COMP
                                        // reallocates mpi resources for the the new mesh. (this will deallocate the old resources)
                                        reallocateMPIResources();
                    #endif

                    if(m_uiMesh->isActive())
                    {
                        /*[[[cog
                        import cog
                        import paramDef as p

                        for var in p.parameters.varsValues():
                            cog.outl("double l_min_{1}=vecMin(m_uiPrevVar[{0}::VAR::{1}]+m_uiMesh->getNodeLocalBegin(),(m_uiMesh->getNumLocalMeshNodes()),m_uiMesh->getMPICommunicator());".format(p.namespace, var.id))
                            cog.outl("double l_max_{1}=vecMax(m_uiPrevVar[{0}::VAR::{1}]+m_uiMesh->getNodeLocalBegin(),(m_uiMesh->getNumLocalMeshNodes()),m_uiMesh->getMPICommunicator());".format(p.namespace, var.id))
                        
                        cog.outl("if(!(m_uiMesh->getMPIRank()))\n{")
                        for var in p.parameters.varsValues():
                            cog.outl("\tstd::cout << \"transfer completed:    ||VAR::{0}|| (min, max) : (\"<<l_min_{0}<<\", \"<<l_max_{0}<<\" ) \"<<std::endl;".format(var.id))
                        cog.outl("}")
                        ]]]*/
                        //[[[end]]]
                    }

                    iterCount+=1;
                }
                applyInitialConditions(m_uiPrevVar);

            }while(isRefine && (newElements_g!=oldElements_g));
        }

        void RK4_NLSM::reallocateMPIResources()
        {
			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("for(unsigned int index=0;index<{0}::ASYNC_COMM_K;index++)".format(namespace))

			]]]*/
			//[[[end]]]
            {
                delete [] m_uiSendNodeBuf[index];
                delete [] m_uiRecvNodeBuf[index];

                delete [] m_uiSendReqs[index];
                delete [] m_uiRecvReqs[index];

                delete [] m_uiSendSts[index];
                delete [] m_uiRecvSts[index];

            }

			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("for(unsigned int index=0;index<{0}::ASYNC_COMM_K;index++)".format(namespace))

			]]]*/
			//[[[end]]]
            {
                m_uiSendNodeBuf[index]=NULL;
                m_uiRecvNodeBuf[index]=NULL;

                m_uiSendReqs[index]=NULL;
                m_uiRecvReqs[index]=NULL;
                m_uiSendSts[index]=NULL;
                m_uiRecvSts[index]=NULL;
            }

            if(m_uiMesh->isActive())
            {
                // allocate mpi comm. reqs and status
				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("for(unsigned int index=0;index<{0}::ASYNC_COMM_K;index++)".format(namespace))

				]]]*/
				//[[[end]]]
                {
                    if(m_uiMesh->getGhostExcgTotalSendNodeCount()!=0) m_uiSendNodeBuf[index]=new double[m_uiMesh->getGhostExcgTotalSendNodeCount()];
                    if(m_uiMesh->getGhostExcgTotalRecvNodeCount()!=0) m_uiRecvNodeBuf[index]=new double[m_uiMesh->getGhostExcgTotalRecvNodeCount()];

                    if(m_uiMesh->getSendProcListSize()!=0)
                    {
                        m_uiSendReqs[index]=new MPI_Request[m_uiMesh->getSendProcListSize()];
                        m_uiSendSts[index]=new MPI_Status[m_uiMesh->getSendProcListSize()];
                    }

                    if(m_uiMesh->getRecvProcListSize()!=0)
                    {
                        m_uiRecvReqs[index]=new MPI_Request[m_uiMesh->getRecvProcListSize()];
                        m_uiRecvSts[index]=new MPI_Status[m_uiMesh->getRecvProcListSize()];
                    }
                }
            }
        }

        void RK4_NLSM::writeToVTU(double **evolZipVarIn, double ** constrZipVarIn, unsigned int numEvolVars,unsigned int numConstVars,const unsigned int * evolVarIndices, const unsigned int * constVarIndices)
        {
			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("{0}::timer::t_ioVtu.start();".format(namespace))

			]]]*/
			//[[[end]]]

            std::vector<std::string> pDataNames;
            double *pData[(numConstVars+numEvolVars+2)];

            for(unsigned int i=0;i<numEvolVars;i++)
            {
				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("pDataNames.push_back(std::string({0}::VAR_NAMES[evolVarIndices[i]]));".format(namespace))

				]]]*/
				//[[[end]]]
                pData[i]=evolZipVarIn[evolVarIndices[i]];
            }

            std::vector<char*> pDataNames_char;
            pDataNames_char.reserve(pDataNames.size());

            for(unsigned int  i = 0; i < pDataNames.size(); i++)
                pDataNames_char.push_back(const_cast<char*>(pDataNames[i].c_str()));

            const char * fDataNames[]={"Time","Cycle"};
            const double fData[]={m_uiCurrentTime,(double)m_uiCurrentStep};

            char fPrefix[256];
			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("sprintf(fPrefix,\"%s_%d\",{0}::VTU_FILE_PREFIX.c_str(),m_uiCurrentStep);".format(namespace))
			cog.outl("io::vtk::mesh2vtuFine(m_uiMesh,fPrefix,2,fDataNames,fData,(numEvolVars+numConstVars),(const char **)&pDataNames_char[0],(const double **)pData);")
			cog.outl("{0}::timer::t_ioVtu.stop();".format(namespace))
			]]]*/
			//[[[end]]]
        }

        void RK4_NLSM::performGhostExchangeVars(double** zipIn)
        {
			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("{0}::timer::t_ghostEx_sync.start();".format(namespace))
			cog.outl("for(unsigned int v=0;v<{0}::NUM_VARS;v++)\n{{".format(namespace))
			cog.outl("\tm_uiMesh->performGhostExchange(zipIn[v]);")
			cog.outl("}\n")

			cog.outl("{0}::timer::t_ghostEx_sync.stop();".format(namespace))
			]]]*/
			//[[[end]]]
        }

        void RK4_NLSM::intergridTransferVars(double**& zipIn, const ot::Mesh* pnewMesh)
        {
			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("{0}::timer::t_gridTransfer.start();".format(namespace))
			cog.outl("for(unsigned int v=0;v<{0}::NUM_VARS;v++)\n{{".format(namespace))
			cog.outl("\tm_uiMesh->interGridTransfer(zipIn[v],pnewMesh);")
			cog.outl("}\n")

			cog.outl("{0}::timer::t_gridTransfer.stop();".format(namespace))
			]]]*/
			//[[[end]]]
        }

        void RK4_NLSM::unzipVars(double** zipIn , double** uzipOut)
        {
			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("{0}::timer::t_unzip_sync.start();".format(namespace))
			cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)\n{{".format(namespace))
			cog.outl("\tm_uiMesh->unzip(zipIn[index],uzipOut[index]);")
			cog.outl("}\n")

			cog.outl("{0}::timer::t_unzip_sync.stop();".format(namespace))
			]]]*/
			//[[[end]]]
        }

        void RK4_NLSM::unzipVars_async(double ** zipIn , double **uzipOut)
        {

			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("{0}::timer::t_unzip_async.start();".format(namespace))
			cog.outl("for(unsigned int var=0;var<{0}::NUM_VARS;var+={0}::ASYNC_COMM_K)\n{{".format(namespace))
			cog.outl("\tfor(unsigned int i=0;(i<{0}::ASYNC_COMM_K);i++)\n\t{{".format(namespace))
			cog.outl("\t\tm_uiMesh->ghostExchangeStart(zipIn[var+i],m_uiSendNodeBuf[i],m_uiRecvNodeBuf[i],m_uiSendReqs[i],m_uiRecvReqs[i]);")
			cog.outl("\t}\n")

			cog.outl("\tfor(unsigned int i=0;(i<{0}::ASYNC_COMM_K);i++)\n\t{{".format(namespace))
			cog.outl("\t\tm_uiMesh->ghostExchangeRecvSync(zipIn[var + i], m_uiRecvNodeBuf[i],m_uiRecvReqs[i], m_uiRecvSts[i]);")
			cog.outl("\t\tm_uiMesh->unzip(zipIn[var+i],uzipOut[var+i]);")
			cog.outl("\t}\n")

			cog.outl("\tfor(unsigned int i=0;(i<{0}::ASYNC_COMM_K);i++)\n\t{{".format(namespace))
			cog.outl("\t\tm_uiMesh->ghostExchangeSendSync(m_uiSendReqs[i], m_uiSendSts[i]);")
			cog.outl("\t}\n}")

			cog.outl("{0}::timer::t_unzip_async.stop();".format(namespace))
			]]]*/
			//[[[end]]]
        }

        void RK4_NLSM::zipVars(double** uzipIn , double** zipOut)
        {
			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("{0}::timer::t_zip.start();".format(namespace))
			cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)\n{{".format(namespace))
			cog.outl("\tm_uiMesh->zip(uzipIn[index],zipOut[index]);")
			cog.outl("}\n")

			cog.outl("{0}::timer::t_zip.stop();".format(namespace))
			]]]*/
			//[[[end]]]
        }

        void RK4_NLSM::applyBoundaryConditions()
        {

        }

        void RK4_NLSM::performSingleIteration()
        {
            bool repeatStep;
            double n_inf_max=0.0;
            double n_inf_max_g=0;

            do
            {
                repeatStep=false;
                n_inf_max=0;
                n_inf_max_g=0;

                if(m_uiMesh->isActive())
                {
                    double current_t=m_uiCurrentTime;
                    double current_t_adv=current_t;

                    #ifdef RK_SOLVER_OVERLAP_COMM_AND_COMP
                                        unzipVars_async(m_uiPrevVar,m_uiUnzipVar);
                    #else
                                        //1. perform ghost exchange.
                                        performGhostExchangeVars(m_uiPrevVar);
                                        //2. unzip all the variables.
                                        unzipVars(m_uiPrevVar,m_uiUnzipVar);
                    #endif

                    int rank =m_uiMesh->getMPIRank();

                    const unsigned int nodeLocalBegin=m_uiMesh->getNodeLocalBegin();
                    const unsigned int nodeLocalEnd=m_uiMesh->getNodeLocalEnd();

                    const std::vector<ot::Block> blkList=m_uiMesh->getLocalBlockList();

                    unsigned int offset;
                    double ptmin[3], ptmax[3];
                    unsigned int sz[3];
                    unsigned int bflag;
                    double dx,dy,dz;

					/*[[[cog
					import cog
					from paramDef import namespace

					cog.outl("const Point pt_min({0}::COMPD_MIN[0],{0}::COMPD_MIN[1],{0}::COMPD_MIN[2]);".format(namespace))
					cog.outl("const Point pt_max({0}::COMPD_MAX[0],{0}::COMPD_MAX[1],{0}::COMPD_MAX[2]);".format(namespace))

					cog.outl("for(unsigned int stage=0;stage<({0}::RK4_STAGES-1);stage++)".format(namespace))
					]]]*/
					//[[[end]]]
                    {

                    #ifdef DEBUG_RK_SOLVER
                                            if(!rank)std::cout<<" stage: "<<stage<<" begin: "<<std::endl;
                                        for(unsigned int index=0;index<nlsm::NLSM_NUM_VARS;index++)
                                            ot::test::isUnzipNaN(m_uiMesh,m_uiUnzipVar[index]);
                    #endif

                        for(unsigned int blk=0;blk<blkList.size();blk++)
                        {
                            offset=blkList[blk].getOffset();
                            sz[0]=blkList[blk].getAllocationSzX();
                            sz[1]=blkList[blk].getAllocationSzY();
                            sz[2]=blkList[blk].getAllocationSzZ();

                            bflag=blkList[blk].getBlkNodeFlag();

                            dx=blkList[blk].computeDx(pt_min,pt_max);
                            dy=blkList[blk].computeDy(pt_min,pt_max);
                            dz=blkList[blk].computeDz(pt_min,pt_max);

                            ptmin[0]=GRIDX_TO_X(blkList[blk].getBlockNode().minX())-3*dx;
                            ptmin[1]=GRIDY_TO_Y(blkList[blk].getBlockNode().minY())-3*dy;
                            ptmin[2]=GRIDZ_TO_Z(blkList[blk].getBlockNode().minZ())-3*dz;

                            ptmax[0]=GRIDX_TO_X(blkList[blk].getBlockNode().maxX())+3*dx;
                            ptmax[1]=GRIDY_TO_Y(blkList[blk].getBlockNode().maxY())+3*dy;
                            ptmax[2]=GRIDZ_TO_Z(blkList[blk].getBlockNode().maxZ())+3*dz;

                            nlsmRhs(m_uiUnzipVarRHS, (const double **)m_uiUnzipVar, offset, ptmin, ptmax, sz, bflag);
                        }

                        #ifdef DEBUG_RK_SOLVER
                                                if(!rank)std::cout<<" stage: "<<stage<<" af rhs UNZIP RHS TEST:"<<std::endl;
                                            for(unsigned int index=0;index<nlsm::NLSM_NUM_VARS;index++)
                                                ot::test::isUnzipInternalNaN(m_uiMesh,m_uiUnzipVarRHS[index]);
                        #endif

                        zipVars(m_uiUnzipVarRHS,m_uiStage[stage]);

                        #ifdef DEBUG_RK_SOLVER
                                                for(unsigned int index=0;index<nlsm::NLSM_NUM_VARS;index++)
                                                if(seq::test::isNAN(m_uiStage[stage][index]+m_uiMesh->getNodeLocalBegin(),m_uiMesh->getNumLocalMeshNodes()))
                                                    std::cout<<" var: "<<index<<" contains nan af zip  stage: "<<stage<<std::endl;
                        #endif

                        /*for(unsigned int index=0;index<nlsm::NLSM_NUM_VARS;index++)
                             for(unsigned int node=nodeLocalBegin;node<nodeLocalEnd;node++)
                                     m_uiStage[stage][index][node]*=m_uiT_h;*/



                        for(unsigned int node=nodeLocalBegin;node<nodeLocalEnd;node++)
                        {
							/*[[[cog
							import cog
							from paramDef import namespace

							cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)".format(namespace))

							]]]*/
							//[[[end]]]
                            {
                                m_uiVarIm[index][node]=m_uiPrevVar[index][node];
                                m_uiVarIm[index][node] += (RK4_U[stage + 1] * m_uiT_h * m_uiStage[stage][index][node]);

                            }
                        }


                        current_t_adv=current_t+RK4_T[stage+1]*m_uiT_h;
                        #ifdef RK_SOLVER_OVERLAP_COMM_AND_COMP
                                                unzipVars_async(m_uiVarIm,m_uiUnzipVar);
                        #else
                                                performGhostExchangeVars(m_uiVarIm);
                                                unzipVars(m_uiVarIm,m_uiUnzipVar);
                        #endif


                    }

					/*[[[cog
					import cog
					from paramDef import namespace

					cog.outl("current_t_adv=current_t+RK4_T[({0}::RK4_STAGES-1)]*m_uiT_h;".format(namespace))

					]]]*/
					//[[[end]]]

                    #ifdef DEBUG_RK_SOLVER
                                        if(!rank)std::cout<<" stage: "<<(nlsm::NLSM_RK4_STAGES-1)<<" begin: "<<std::endl;

                                    for(unsigned int index=0;index<nlsm::NLSM_NUM_VARS;index++)
                                        ot::test::isUnzipNaN(m_uiMesh,m_uiUnzipVar[index]);
                    #endif


                    for(unsigned int blk=0;blk<blkList.size();blk++)
                    {
                        offset=blkList[blk].getOffset();
                        sz[0]=blkList[blk].getAllocationSzX();
                        sz[1]=blkList[blk].getAllocationSzY();
                        sz[2]=blkList[blk].getAllocationSzZ();

                        bflag=blkList[blk].getBlkNodeFlag();

                        dx=blkList[blk].computeDx(pt_min,pt_max);
                        dy=blkList[blk].computeDy(pt_min,pt_max);
                        dz=blkList[blk].computeDz(pt_min,pt_max);

                        ptmin[0]=GRIDX_TO_X(blkList[blk].getBlockNode().minX())-3*dx;
                        ptmin[1]=GRIDY_TO_Y(blkList[blk].getBlockNode().minY())-3*dy;
                        ptmin[2]=GRIDZ_TO_Z(blkList[blk].getBlockNode().minZ())-3*dz;

                        ptmax[0]=GRIDX_TO_X(blkList[blk].getBlockNode().maxX())+3*dx;
                        ptmax[1]=GRIDY_TO_Y(blkList[blk].getBlockNode().maxY())+3*dy;
                        ptmax[2]=GRIDZ_TO_Z(blkList[blk].getBlockNode().maxZ())+3*dz;

                        nlsmRhs(m_uiUnzipVarRHS, (const double **)m_uiUnzipVar, offset, ptmin, ptmax, sz, bflag);
                    }

                    #ifdef DEBUG_RK_SOLVER
                                        if(!rank)std::cout<<" stage: "<<(nlsm::NLSM_RK4_STAGES-1)<<" af rhs UNZIP RHS TEST:"<<std::endl;
                                        for(unsigned int index=0;index<nlsm::NLSM_NUM_VARS;index++)
                                            ot::test::isUnzipInternalNaN(m_uiMesh,m_uiUnzipVarRHS[index]);
                    #endif

					/*[[[cog
					import cog
					from paramDef import namespace

					cog.outl("zipVars(m_uiUnzipVarRHS,m_uiStage[({0}::RK4_STAGES-1)]);".format(namespace))

					]]]*/
					//[[[end]]]

                    for(unsigned int node=nodeLocalBegin;node<nodeLocalEnd;node++)
                    {
						/*[[[cog
						import cog
						from paramDef import namespace

						cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)\n{{".format(namespace))
						cog.outl("\tm_uiVar[index][node]=m_uiPrevVar[index][node];")
						cog.outl("\tfor(unsigned int s=0;s<({0}::RK4_STAGES);s++)\n{{".format(namespace))
						cog.outl("\t\tm_uiVar[index][node]+=(RK4_C[s]*m_uiT_h*m_uiStage[s][index][node]);")
						cog.outl("\t}\n}")
						]]]*/
						//[[[end]]]
                    }
                }

                m_uiMesh->waitAll();

            }while(repeatStep);

            m_uiCurrentStep++;
            m_uiCurrentTime+=m_uiT_h;
        }

        void RK4_NLSM::rkSolve()
        {
            if(m_uiCurrentStep==0)
            {
                applyInitialConditions(m_uiPrevVar);
                initialGridConverge();
            }

            bool isRefine=true;
            unsigned int oldElements,oldElements_g;
            unsigned int newElements,newElements_g;

			/*[[[cog
			import cog
			from paramDef import namespace

			cog.outl("const unsigned int refineNumVars={0}::NUM_REFINE_VARS;".format(namespace))
			cog.outl("unsigned int refineVarIds[refineNumVars];")
			cog.outl("for(unsigned int vIndex=0;vIndex<refineNumVars;vIndex++)\n{")
			cog.outl("\trefineVarIds[vIndex]={0}::REFINE_VARIABLE_INDICES[vIndex];".format(namespace))
			cog.outl("}\n")

			cog.outl("double minTol={0}::RK_MIN_TOL;".format(namespace))
			]]]*/
			//[[[end]]]

            std::function<double(double,double,double)> tolFunc =[minTol](double x,double y, double z)
			{ 
				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("return {0}::computeTol(x,y,z,minTol);".format(namespace))

				]]]*/
				//[[[end]]]
			};

            /*[[[cog
            import cog
            import paramDef as p

            cog.out("double ")
            first = True
            for var in p.parameters.varsValues():
                if not first:
                    cog.out(", ")
                first = False

                cog.out("l_min_{0}, l_max_{0}".format(var.id))
            cog.outl(";")
            cog.outl("for(double t=m_uiCurrentTime;t<m_uiTimeEnd;t=t+m_uiT_h)\n{")

            cog.outl("\t// checkpoint the previous solution value before going to the next step.")
            cog.outl("\t{0}::timer::t_ioCheckPoint.start();".format(p.namespace))
            cog.outl("\tif((m_uiMesh->isActive()) && (m_uiCurrentStep%{0}::CHECKPT_FREQ)==0)\n\t{{".format(p.namespace))
            cog.outl("\t\tstoreCheckPoint({0}::CHKPT_FILE_PREFIX.c_str());".format(p.namespace))
            cog.outl("\t}\n")
            cog.outl("\t{0}::timer::t_ioCheckPoint.stop();".format(p.namespace))
				
            cog.outl("\t// write sol to vtu.")
            cog.outl("\tif((m_uiMesh->isActive()) && (m_uiCurrentStep%{0}::TIME_STEP_OUTPUT_FREQ)==0)\n\t{{".format(p.namespace))

            for var in p.parameters.varsValues():
                cog.outl("\t\tl_min_{1}=vecMin(m_uiPrevVar[{0}::VAR::{1}]+m_uiMesh->getNodeLocalBegin(),(m_uiMesh->getNumLocalMeshNodes()),m_uiMesh->getMPICommunicator());".format(p.namespace, var.id))
                cog.outl("\t\tl_max_{1}=vecMax(m_uiPrevVar[{0}::VAR::{1}]+m_uiMesh->getNodeLocalBegin(),(m_uiMesh->getNumLocalMeshNodes()),m_uiMesh->getMPICommunicator());".format(p.namespace, var.id))

            cog.outl("\n\t\tif(!(m_uiMesh->getMPIRank()))\n\t\t{")
            cog.outl("\t\t\tstd::cout << \"executing step: \" << m_uiCurrentStep << \" dt: \" << m_uiT_h << \" rk_time : \"<< m_uiCurrentTime << std::endl;")
            for var in p.parameters.varsValues():
                cog.outl("\t\t\tstd::cout << \"\\t ||VAR::{0}|| (min, max) : (\"<<l_min_{0}<<\", \"<<l_max_{0}<<\" ) \"<<std::endl;".format(var.id))
            cog.outl("\t\t}")

            cog.outl("\t\t{0}::timer::profileInfoIntermediate({0}::PROFILE_FILE_PREFIX.c_str(),m_uiMesh,m_uiCurrentStep);".format(p.namespace))
            cog.outl("\t}\n")

            cog.outl("\tif((m_uiCurrentStep%{0}::TIME_STEP_OUTPUT_FREQ)==0)\n\t{{".format(p.namespace))
            cog.outl("\t\t{0}::timer::resetSnapshot();".format(p.namespace))
            cog.outl("\t}\n")

            cog.outl("\tif((m_uiCurrentStep%{0}::REMESH_TEST_FREQ)==0)".format(p.namespace))
            ]]]*/
            //[[[end]]]
                {

                    #ifdef RK_SOLVER_OVERLAP_COMM_AND_COMP
                                        unzipVars_async(m_uiPrevVar,m_uiUnzipVar);
                    #else
                                        performGhostExchangeVars(m_uiPrevVar);
                                        unzipVars(m_uiPrevVar,m_uiUnzipVar);
                    #endif
                    
                    #ifdef DEBUG_RK_SOLVER
                                        if(m_uiMesh->isActive())
                                        {
                                            if(!m_uiMesh->getMPIRank())std::cout<<" isRemesh Unzip : "<<std::endl;
                                            for(unsigned int index=0;index<nlsm::NLSM_NUM_VARS;index++)
                                                ot::test::isUnzipNaN(m_uiMesh,m_uiUnzipVar[index]);

                                        }
                    #endif

					/*[[[cog
					import cog
					from paramDef import namespace

					cog.outl("{0}::timer::t_isReMesh.start();".format(namespace))
					cog.outl("if({0}::ENABLE_BLOCK_ADAPTIVITY)\n{{".format(namespace))
					cog.outl("\tisRefine=false;")
					cog.outl("}\nelse\n{")
					cog.outl("\tisRefine=m_uiMesh->isReMeshUnzip((const double **)m_uiUnzipVar,refineVarIds,refineNumVars,tolFunc,{0}::DENDRO_AMR_FAC);".format(namespace))
					cog.outl("}\n")
					
					cog.outl("{0}::timer::t_isReMesh.stop();".format(namespace))
					]]]*/
					//[[[end]]]

                    if(isRefine)
                    {
                        #ifdef DEBUG_IS_REMESH
                            unsigned int rank=m_uiMesh->getMPIRankGlobal();
                            MPI_Comm globalComm=m_uiMesh->getMPIGlobalCommunicator();
                            std::vector<ot::TreeNode> unChanged;
                            std::vector<ot::TreeNode> refined;
                            std::vector<ot::TreeNode> coarsened;
                            std::vector<ot::TreeNode> localBlocks;

                            const ot::Block* blkList=&(*(m_uiMesh->getLocalBlockList().begin()));
                            for(unsigned int ele=0;ele<m_uiMesh->getLocalBlockList().size();ele++)
                            {
                                localBlocks.push_back(blkList[ele].getBlockNode());
                            }


                            const ot::TreeNode * pNodes=&(*(m_uiMesh->getAllElements().begin()));
                            for(unsigned int ele=m_uiMesh->getElementLocalBegin();ele<m_uiMesh->getElementLocalEnd();ele++)
                            {
                                if((pNodes[ele].getFlag()>>NUM_LEVEL_BITS)==OCT_NO_CHANGE)
                                {
                                    unChanged.push_back(pNodes[ele]);
                                }else if((pNodes[ele].getFlag()>>NUM_LEVEL_BITS)==OCT_SPLIT)
                                {
                                    refined.push_back(pNodes[ele]);
                                }else
                                {
                                    assert((pNodes[ele].getFlag()>>NUM_LEVEL_BITS)==OCT_COARSE);
                                    coarsened.push_back(pNodes[ele]);
                                }
                            }

                            char fN1[256];
                            char fN2[256];
                            char fN3[256];
                            char fN4[256];

                            sprintf(fN1,"unchanged_%d",m_uiCurrentStep);
                            sprintf(fN2,"refined_%d",m_uiCurrentStep);
                            sprintf(fN3,"coarsend_%d",m_uiCurrentStep);
                            sprintf(fN4,"blocks_%d",m_uiCurrentStep);

                            DendroIntL localSz=unChanged.size();
                            DendroIntL globalSz;
                            par::Mpi_Reduce(&localSz,&globalSz,1,MPI_SUM,0,globalComm);
                            if(!rank) std::cout<<" total unchanged: "<<globalSz<<std::endl;

                            localSz=refined.size();
                            par::Mpi_Reduce(&localSz,&globalSz,1,MPI_SUM,0,globalComm);
                            if(!rank) std::cout<<" total refined: "<<globalSz<<std::endl;


                            localSz=coarsened.size();
                            par::Mpi_Reduce(&localSz,&globalSz,1,MPI_SUM,0,globalComm);
                            if(!rank) std::cout<<" total coarsend: "<<globalSz<<std::endl;


                            io::vtk::oct2vtu(&(*(unChanged.begin())),unChanged.size(),fN1,globalComm);
                            io::vtk::oct2vtu(&(*(refined.begin())),refined.size(),fN2,globalComm);
                            io::vtk::oct2vtu(&(*(coarsened.begin())),coarsened.size(),fN3,globalComm);
                            io::vtk::oct2vtu(&(*(localBlocks.begin())),localBlocks.size(),fN4,globalComm);

                        #endif

						/*[[[cog
						import cog
						from paramDef import namespace

						cog.outl("{0}::timer::t_mesh.start();".format(namespace))
						cog.outl("ot::Mesh* newMesh=m_uiMesh->ReMesh({0}::DENDRO_GRAIN_SZ,{0}::LOAD_IMB_TOL,{0}::SPLIT_FIX);".format(namespace))
						cog.outl("{0}::timer::t_mesh.stop();\n".format(namespace))

						]]]*/
						//[[[end]]]

                        oldElements=m_uiMesh->getNumLocalMeshElements();
                        newElements=newMesh->getNumLocalMeshElements();

                        par::Mpi_Reduce(&oldElements,&oldElements_g,1,MPI_SUM,0,m_uiMesh->getMPIGlobalCommunicator());
                        par::Mpi_Reduce(&newElements,&newElements_g,1,MPI_SUM,0,newMesh->getMPIGlobalCommunicator());
                        
                        if(!(m_uiMesh->getMPIRankGlobal()))std::cout<<"step : "<<m_uiCurrentStep<<" time : "<<m_uiCurrentTime<<" old mesh: "<<oldElements_g<<" new mesh: "<<newElements_g<<std::endl;


                        // performs the inter-grid transfer
                        intergridTransferVars(m_uiPrevVar,newMesh);

						/*[[[cog
						import cog
						from paramDef import namespace

						cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)".format(namespace))

						]]]*/
						//[[[end]]]
                        {
                            delete [] m_uiVar[index];
                            delete [] m_uiVarIm[index];
                            delete [] m_uiUnzipVar[index];
                            delete [] m_uiUnzipVarRHS[index];

                            m_uiVar[index]=NULL;
                            m_uiVarIm[index]=NULL;
                            m_uiUnzipVar[index]=NULL;
                            m_uiUnzipVarRHS[index]=NULL;

                            m_uiVar[index]=newMesh->createVector<double>();
                            m_uiVarIm[index]=newMesh->createVector<double>();
                            m_uiUnzipVar[index]=newMesh->createUnZippedVector<double>();
                            m_uiUnzipVarRHS[index]=newMesh->createUnZippedVector<double>();


                        }

						/*[[[cog
						import cog
						from paramDef import namespace

						cog.outl("for(unsigned int stage=0;stage<{0}::RK4_STAGES;stage++)\n{{".format(namespace))
						cog.outl("\tfor(unsigned int index=0;index<{0}::NUM_VARS;index++)\n{{".format(namespace))
						cog.outl("\t\tdelete[] m_uiStage[stage][index];")
						cog.outl("\t\tm_uiStage[stage][index] = NULL;")
						cog.outl("\t\tm_uiStage[stage][index] = newMesh->createVector<double>();")
						cog.outl("\t}\n}\n")
						]]]*/
						//[[[end]]]

                        std::swap(newMesh,m_uiMesh);
                        delete newMesh;

                        #ifdef RK_SOLVER_OVERLAP_COMM_AND_COMP
                            // reallocates mpi resources for the the new mesh. (this will deallocate the old resources)
                            reallocateMPIResources();
                        #endif

                        if(m_uiMesh->isActive())
                        {
                            /*[[[cog
                            import cog
                            import paramDef as p

                            for var in p.parameters.varsValues():
                                cog.outl("l_min_{1}=vecMin(m_uiPrevVar[{0}::VAR::{1}]+m_uiMesh->getNodeLocalBegin(),(m_uiMesh->getNumLocalMeshNodes()),m_uiMesh->getMPICommunicator());".format(p.namespace, var.id))
                                cog.outl("l_max_{1}=vecMax(m_uiPrevVar[{0}::VAR::{1}]+m_uiMesh->getNodeLocalBegin(),(m_uiMesh->getNumLocalMeshNodes()),m_uiMesh->getMPICommunicator());".format(p.namespace, var.id))

                            cog.outl("if(!(m_uiMesh->getMPIRank()))\n{")
                            for var in p.parameters.varsValues():
                                cog.outl("\tstd::cout << \"transfer completed:    ||VAR::{0}|| (min, max) : (\"<<l_min_{0}<<\", \"<<l_max_{0}<<\" ) \"<<std::endl;".format(var.id))
                            cog.outl("}")
                            ]]]*/
                            //[[[end]]]
                        }
                    }
                }

				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("if((m_uiCurrentStep%{0}::IO_OUTPUT_FREQ)==0)".format(namespace))

				]]]*/
				//[[[end]]]
                {

                    #ifdef RK_SOLVER_OVERLAP_COMM_AND_COMP
                    unzipVars_async(m_uiPrevVar,m_uiUnzipVar);
                    #else
                    performGhostExchangeVars(m_uiPrevVar);
                    unzipVars(m_uiPrevVar,m_uiUnzipVar);
                    #endif

					/*[[[cog
					import cog
					from paramDef import namespace

					cog.outl("writeToVTU(m_uiPrevVar,m_uiConstraintVars,{0}::NUM_EVOL_VARS_VTU_OUTPUT,0,{0}::VTU_OUTPUT_EVOL_INDICES,NULL);".format(namespace))

					]]]*/
					//[[[end]]]
                }

				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("{0}::timer::t_rkStep.start();".format(namespace))
				cog.outl("performSingleIteration();")
				cog.outl("{0}::timer::t_rkStep.stop();".format(namespace))

				]]]*/
				//[[[end]]]

                std::swap(m_uiVar,m_uiPrevVar);
            }
        }

        void RK4_NLSM::storeCheckPoint(const char * fNamePrefix)
        {
            if(m_uiMesh->isActive())
            {
                unsigned int cpIndex;

				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("(m_uiCurrentStep%(2*{0}::CHECKPT_FREQ)==0) ? cpIndex=0 : cpIndex=1;".format(namespace))

				]]]*/
				//[[[end]]]
                unsigned int rank=m_uiMesh->getMPIRank();
                unsigned int npes=m_uiMesh->getMPICommSize();

                char fName[256];
                const ot::TreeNode * pNodes=&(*(m_uiMesh->getAllElements().begin()+m_uiMesh->getElementLocalBegin()));
                sprintf(fName,"%s_octree_%d_%d.oct",fNamePrefix,cpIndex,rank);
                io::checkpoint::writeOctToFile(fName,pNodes,m_uiMesh->getNumLocalMeshElements());

				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("unsigned int numVars={0}::NUM_VARS;".format(namespace))
				cog.outl("const char ** varNames={0}::VAR_NAMES;".format(namespace))
				cog.outl("sprintf(fName,\"%s_%d_%d.var\",fNamePrefix,cpIndex,rank);")
				cog.outl("io::checkpoint::writeVecToFile(fName,m_uiMesh,(const double **)m_uiPrevVar,{0}::NUM_VARS);".format(namespace))
				]]]*/
				//[[[end]]]

                if(!rank)
                {
                    sprintf(fName,"%s_step_%d.cp",fNamePrefix,cpIndex);
                    std::ofstream outfile(fName);
                    if(!outfile) {std::cout<<fName<<" file open failed "<<std::endl; return ;}

                    json checkPoint;
                    checkPoint["DENDRO_RK45_TIME_BEGIN"]=m_uiTimeBegin;
                    checkPoint["DENDRO_RK45_TIME_END"]=m_uiTimeEnd;
                    checkPoint["DENDRO_RK45_ELEMENT_ORDER"]=m_uiOrder;

                    checkPoint["DENDRO_RK45_TIME_CURRENT"]=m_uiCurrentTime;
                    checkPoint["DENDRO_RK45_STEP_CURRENT"]=m_uiCurrentStep;
                    checkPoint["DENDRO_RK45_TIME_STEP_SIZE"]=m_uiT_h;
                    checkPoint["DENDRO_RK45_LAST_IO_TIME"]=m_uiCurrentTime;

					/*[[[cog
					import cog
					from paramDef import namespace

					####TODO: safe to change checkpoint names?
					cog.outl("checkPoint[\"DENDRO_RK45_WAVELET_TOLERANCE\"]={0}::RK_MIN_TOL;".format(namespace))
					cog.outl("checkPoint[\"DENDRO_RK45_LOAD_IMB_TOLERANCE\"]={0}::LOAD_IMB_TOL;".format(namespace))

					]]]*/
					//[[[end]]]
                    checkPoint["DENDRO_RK45_NUM_VARS"]=numVars; // number of variables to restore.
                    checkPoint["DENDRO_RK45_ACTIVE_COMM_SZ"]=m_uiMesh->getMPICommSize(); // (note that rank 0 is always active).

                    outfile<<std::setw(4)<<checkPoint<<std::endl;
                    outfile.close();
                }
            }
        }

        void RK4_NLSM::restoreCheckPoint(const char * fNamePrefix,MPI_Comm comm)
        {
            unsigned int numVars=0;
            std::vector<ot::TreeNode> octree;
            json checkPoint;

            int rank;
            int npes;
            m_uiComm=comm;
            MPI_Comm_rank(m_uiComm,&rank);
            MPI_Comm_size(m_uiComm,&npes);

            unsigned int activeCommSz;

            char fName[256];
            unsigned int restoreStatus=0;
            unsigned int restoreStatusGlobal=0; // 0 indicates successfully restorable.

            ot::Mesh* newMesh;

            for(unsigned int cpIndex=0;cpIndex<2;cpIndex++)
            {
                restoreStatus=0;
                octree.clear();
                if(!rank) std::cout<<" Trying to restore from checkpoint index : "<<cpIndex<<std::endl;

                if(!rank)
                {
                    sprintf(fName,"%s_step_%d.cp",fNamePrefix,cpIndex);
                    std::ifstream infile(fName);
                    if(!infile) {std::cout<<fName<<" file open failed "<<std::endl; restoreStatus=1;}


                    if(restoreStatus==0)
                    {
                        infile>>checkPoint;
                        m_uiTimeBegin=checkPoint["DENDRO_RK45_TIME_BEGIN"];
                        m_uiTimeEnd=checkPoint["DENDRO_RK45_TIME_END"];

                        m_uiOrder=checkPoint["DENDRO_RK45_ELEMENT_ORDER"];
                        m_uiCurrentTime=checkPoint["DENDRO_RK45_TIME_CURRENT"];
                        m_uiCurrentStep=checkPoint["DENDRO_RK45_STEP_CURRENT"];
                        m_uiT_h=checkPoint["DENDRO_RK45_TIME_STEP_SIZE"];
			
						/*[[[cog
						import cog
						from paramDef import namespace

						####TODO: Check if OK to change this checkpoint id
						cog.outl("{0}::RK_MIN_TOL=checkPoint[\"DENDRO_RK45_WAVELET_TOLERANCE\"];".format(namespace))
						cog.outl("{0}::LOAD_IMB_TOL=checkPoint[\"DENDRO_RK45_LOAD_IMB_TOLERANCE\"];".format(namespace))

						]]]*/
						//[[[end]]]
                        numVars=checkPoint["DENDRO_RK45_NUM_VARS"];
                        activeCommSz=checkPoint["DENDRO_RK45_ACTIVE_COMM_SZ"];
                    }
                }

                par::Mpi_Allreduce(&restoreStatus,&restoreStatusGlobal,1,MPI_MAX,m_uiComm);
                if(restoreStatusGlobal==1) continue;

                par::Mpi_Bcast(&m_uiTimeBegin,1,0,comm);
                par::Mpi_Bcast(&m_uiTimeEnd,1,0,comm);

                par::Mpi_Bcast(&m_uiCurrentTime,1,0,comm);
                par::Mpi_Bcast(&m_uiCurrentStep,1,0,comm);

                par::Mpi_Bcast(&m_uiT_h,1,0,comm);

				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("par::Mpi_Bcast(&{0}::RK_MIN_TOL,1,0,comm);".format(namespace))
				cog.outl("par::Mpi_Bcast(&{0}::LOAD_IMB_TOL,1,0,comm);".format(namespace))

				]]]*/
				//[[[end]]]

                par::Mpi_Bcast(&numVars,1,0,comm);
                par::Mpi_Bcast(&m_uiOrder,1,0,comm);
                par::Mpi_Bcast(&m_uiT_h,1,0,comm);

                par::Mpi_Bcast(&activeCommSz,1,0,comm);

                if(activeCommSz>npes)
                {
                    if(!rank)std::cout<<" [Error] : checkpoint file written from  a larger communicator than the current global comm. (i.e. communicator shrinking not allowed in the restore step. )"<<std::endl;
                    exit(0);
                }

                bool isActive=(rank<activeCommSz);

                MPI_Comm newComm;
                par::splitComm2way(isActive,&newComm,m_uiComm);

                if(isActive) {

                    int activeRank;
                    int activeNpes;

                    MPI_Comm_rank(newComm, &activeRank);
                    MPI_Comm_size(newComm, &activeNpes);
                    assert(activeNpes == activeCommSz);

                    sprintf(fName, "%s_octree_%d_%d.oct", fNamePrefix,cpIndex,activeRank);
                    restoreStatus=io::checkpoint::readOctFromFile(fName, octree);
                    assert(par::test::isUniqueAndSorted(octree, newComm));

                }

                par::Mpi_Allreduce(&restoreStatus,&restoreStatusGlobal,1,MPI_MAX,m_uiComm);
                if(restoreStatusGlobal==1) {

                    if(!rank) std::cout<<"[Error]: octree (*.oct) restore file currupted "<<std::endl;
                    continue;
                }

                newMesh=new ot::Mesh(octree,1,m_uiOrder,activeCommSz,m_uiComm);

				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("for(unsigned int index=0;index<{0}::NUM_VARS;index++)".format(namespace))

				]]]*/
				//[[[end]]]
                {
                    delete [] m_uiPrevVar[index];
                    delete [] m_uiVar[index];
                    delete [] m_uiVarIm[index];
                    delete [] m_uiUnzipVar[index];
                    delete [] m_uiUnzipVarRHS[index];

                    m_uiPrevVar[index]=newMesh->createVector<double>();
                    m_uiVar[index]=newMesh->createVector<double>();
                    m_uiVarIm[index]=newMesh->createVector<double>();
                    m_uiUnzipVar[index]=newMesh->createUnZippedVector<double>();
                    m_uiUnzipVarRHS[index]=newMesh->createUnZippedVector<double>();
                }

				/*[[[cog
				import cog
				from paramDef import namespace

				cog.outl("for(unsigned int stage=0;stage<{0}::RK4_STAGES;stage++)\n{{".format(namespace))
				cog.outl("\tfor(unsigned int index=0;index<{0}::NUM_VARS;index++)\n\t{{".format(namespace))
				cog.outl("\t\tdelete [] m_uiStage[stage][index];")
				cog.outl("\t\tm_uiStage[stage][index]=newMesh->createVector<double>();")
				cog.outl("\t}\n}")
				cog.outl("const char ** varNames={0}::VAR_NAMES;".format(namespace))
				]]]*/
				//[[[end]]]

                if(isActive) {

                    int activeRank;
                    int activeNpes;

                    MPI_Comm_rank(newComm, &activeRank);
                    MPI_Comm_size(newComm, &activeNpes);
                    assert(activeNpes == activeCommSz);

                    sprintf(fName,"%s_%d_%d.var",fNamePrefix,cpIndex,activeRank);

					/*[[[cog
					import cog
					from paramDef import namespace

					cog.outl("restoreStatus=io::checkpoint::readVecFromFile(fName,newMesh,m_uiPrevVar,{0}::NUM_VARS);".format(namespace))

					]]]*/
					//[[[end]]]
                }
                MPI_Comm_free(&newComm);
                par::Mpi_Allreduce(&restoreStatus,&restoreStatusGlobal,1,MPI_MAX,m_uiComm);
                if(restoreStatusGlobal==1) {

                    if(!rank) std::cout<<"[Error]: varible (*.var) restore file currupted "<<std::endl;
                    continue;
                }

                std::swap(m_uiMesh,newMesh);
                delete newMesh;
                reallocateMPIResources();
                if(restoreStatusGlobal==0) break;

            }

            if(restoreStatusGlobal==1){
                std::cout<<"rank: "<<rank<<"[Error]: rk solver restore error "<<std::endl;
                exit(0);
            }

            unsigned int localSz=m_uiMesh->getNumLocalMeshElements();
            unsigned int totalElems;

            par::Mpi_Allreduce(&localSz,&totalElems,1,MPI_SUM,m_uiComm);

            if(!rank) std::cout<<" checkpoint at step : "<<m_uiCurrentStep<<"active Comm. sz: "<<activeCommSz<<" restore successful: "<<" restored mesh size: "<<totalElems<<std::endl;
            return;
        }
    }// end of namespace solver
} // end of namespace ode
